
      <!DOCTYPE html>
      <html lang="ja">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>計画</title>
        <link rel="stylesheet" href="../style.css">
        <style>
          @font-face {
            font-family: 'IPAGothic';
            src: local('IPAGothic');
          }
          @font-face {
            font-family: 'IPAMincho';
            src: local('IPAMincho');
          }
          html, body {
            font-family: "IPAGothic", "Noto Sans CJK JP", "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif;
            line-height: 1.8;
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
          }
          pre {
            background-color: #f6f8fa;
            border-radius: 3px;
            padding: 16px;
            overflow: auto;
          }
          code {
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
            background-color: rgba(27, 31, 35, 0.05);
            border-radius: 3px;
            padding: 0.2em 0.4em;
          }
          pre code {
            background-color: transparent;
            padding: 0;
          }
          blockquote {
            border-left: 4px solid #ddd;
            padding-left: 16px;
            color: #555;
            margin-left: 0;
          }
          img {
            max-width: 100%;
            height: auto;
          }
          table {
            border-collapse: collapse;
            width: 100%;
          }
          table, th, td {
            border: 1px solid #ddd;
          }
          th, td {
            padding: 8px 12px;
          }
          th {
            background-color: #f6f8fa;
          }
        </style>
      </head>
      <body>
        <h2>JavaScript学習ロードマップ：基礎から実践、そして専門分野へ</h2>
<hr>
<h3>序章: 学習を始める前に – 装備と心構え</h3>
<ul>
<li><strong>目的</strong>: JavaScript学習をスムーズに始めるための環境構築、基本的なツール操作、学習の心構えを身につける。</li>
<li><strong>内容</strong>:<ol>
<li><strong>はじめに</strong>: JavaScript専門家への道 – この学習プランの意義と最終目標。<ul>
<li>学習計画の全体像と、各段階で習得できるスキルの概要。</li>
</ul>
</li>
<li><strong>学習環境の構築</strong>: あなたのデジタル工房をセットアップ。<ul>
<li>テキストエディタ: VSCode (基本操作、ターミナル連携)。<ul>
<li><strong>推奨拡張機能</strong>:<ul>
<li>Live Server: 「リアルタイムプレビューの魔法。」</li>
<li>ESLint: 「コードの文法・品質チェッカー先生。」 (設定方法にも軽く触れる)</li>
<li>Prettier: 「コード整形職人。」 (保存時自動整形の設定推奨)</li>
</ul>
</li>
</ul>
</li>
<li>ウェブブラウザ: Chrome または Firefox (開発者ツールのコンソール、要素タブ、ソースタブの基本操作)。</li>
<li>Node.js: LTS版をインストール (<code>node -v</code>, <code>npm -v</code> でバージョン確認)。<ul>
<li>簡単なJavaScriptファイルの実行方法 (<code>node myfile.js</code>)。</li>
<li><strong>Node.jsの役割の展望</strong>: 「今は簡単なJS実行に使うけど、実はウェブサイトの裏側（サーバー）を動かしたり、開発を助ける便利な道具（ビルドツール）を動かしたりする、とてもパワフルなやつなんだ。その話はまたずっと後でね！」</li>
</ul>
</li>
</ul>
</li>
<li><strong>バージョン管理システム</strong>: あなたのコードのタイムマシン。<ul>
<li>Git: インストールと初期設定。<ul>
<li>基本コマンド: <code>git init</code>, <code>git status</code>, <code>git add &lt;file&gt;</code>, <code>git commit -m &quot;message&quot;</code>, <code>git log</code>, <code>git diff</code>。</li>
<li><strong>ブランチ戦略入門</strong>: <code>git branch &lt;branch-name&gt;</code>, <code>git checkout &lt;branch-name&gt;</code> (例: <code>feature/login-form</code>)。「ログインフォームを作るぞ！という時に、本流から分岐して専用の作業スペースを作るイメージです。失敗しても本流は安全！」</li>
</ul>
</li>
<li>GitHub: アカウント作成、リモートリポジトリ作成、<code>git remote add origin &lt;url&gt;</code>, <code>git push -u origin main</code>。</li>
</ul>
</li>
<li><strong>デバッグの心構えと基本スキル</strong>: 問題解決は成長のエンジン。<ul>
<li><code>console.log()</code>: 「最も身近な探偵道具。」変数の値確認、処理の通過点確認。<ul>
<li><code>console.table()</code>: 配列やオブジェクトを見やすく表示するテクニック。<code>const users = [{name: &quot;Alice&quot;, age: 30}, {name: &quot;Bob&quot;, age: 25}]; console.table(users);</code></li>
</ul>
</li>
<li>エラーメッセージを読む習慣: 「エラーはヒントの宝庫。」<ul>
<li>代表的なエラー例: <code>ReferenceError: myFunction is not defined</code> → 「<code>myFunction</code>という名前のものがどこにも見つからないよ、というエラーです。関数名や変数名のタイプミス、または定義する前に呼び出そうとしていないか確認しましょう。」</li>
</ul>
</li>
<li>ブラウザ開発者ツールのデバッガ:<ul>
<li>ブレークポイントの設定、ステップ実行（ステップオーバー、ステップイン、ステップアウト）。</li>
<li>ウォッチ式での変数の変化の追跡。</li>
<li>コールスタックでの関数の呼び出し階層の確認。</li>
<li><strong>VSCodeデバッガとの連携</strong>: VSCodeのデバッガ画面のスクリーンショット（各機能のボタンを指し示すなど）と共に示す。</li>
</ul>
</li>
<li>問題の切り分け: 「複雑な問題は小さく分けて考える。」</li>
</ul>
</li>
<li><strong>学習の進め方と心構え</strong>: 長い旅路を楽しみながら進むために。<ul>
<li>このプランの段階的消化の勧め。</li>
<li>「手を動かす」ことの絶対的な重要性。</li>
<li>小さな成功体験を積み重ねる。</li>
<li>公式ドキュメント (MDN Web Docs) と信頼できる情報源の活用。</li>
<li>コミュニティの活用と質問のマナー (Stack Overflow, teratailなど)。</li>
<li>「なぜ？」を問い続ける姿勢: 「このAPIはなぜGETリクエストでデータを取得するのだろう？POSTではダメなのか？」「このライブラリはなぜこのような設計思想で作られたのだろう？他のアプローチはなかったのか？」など、技術選択や設計の背景を問う例を追加。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h3>第1部: JavaScriptの言語核</h3>
<h4>第1章: JavaScriptとは – 言語特性と最初の一歩</h4>
<ul>
<li><strong>目的</strong>: JavaScriptの基本的な特徴、HTML/CSSとの関係、そしてプログラムを書く上での最初のお作法を学ぶ。</li>
<li><strong>内容</strong>:<ol>
<li><strong>JavaScriptの概要</strong>:<ul>
<li>HTML/CSSとの関係: ウェブページの構造（HTML）、見た目（CSS）、動き（JavaScript）の役割分担。<ul>
<li>HTMLファイルとJavaScriptファイルを連携させる簡単な例: <code>&lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;</code> (外部ファイル)、<code>&lt;script&gt;/* ここにコード */&lt;/script&gt;</code> (インライン)。</li>
</ul>
</li>
<li>実行環境: ブラウザ (フロントエンド) vs Node.js (サーバーサイド、ツール)。</li>
</ul>
</li>
<li><strong>JavaScriptの主な言語特性</strong>:<ul>
<li>動的型付け: メリット・デメリット。TypeScriptへの布石。</li>
<li>プロトタイプベースのオブジェクト指向: 「クラスではなくプロトタイプをベースとした柔軟なオブジェクトモデル。」<ul>
<li><strong>歴史的経緯</strong>: 「Javaアプレットが重厚長大だったのに対し、ウェブページに手軽に動きを加えられる軽量なスクリプト言語として、Brendan Eich氏がわずか10日間で設計したと言われています。その際、Self言語などの影響を受け、クラスではなくプロトタイプをベースとした柔軟なオブジェクトモデルが採用されました。」</li>
</ul>
</li>
<li>関数型プログラミングの側面: 関数は第一級オブジェクト。<ul>
<li><p><strong>高階関数もどき</strong>:</p>
<pre><code class="language-javascript">// filepath: (第1章の説明箇所)
function operateOnArray(array, operation) {
  const result = [];
  for (let i = 0; i &lt; array.length; i++) {
    result.push(operation(array[i]));
  }
  return result;
}
const numbers = [1, 2, 3];
const doubled = operateOnArray(numbers, function(num) { return num * 2; }); // [2, 4, 6]
</code></pre>
<p>  「<code>operation</code> に渡す関数を変えるだけで、配列に対する処理内容を自由に変えられるのが面白いところです。」</p>
</li>
</ul>
</li>
<li>イベント駆動型プログラミング: ユーザーのアクションやシステムの出来事に応じて処理が実行されるモデル（概念紹介）。</li>
</ul>
</li>
<li><strong>JavaScriptプログラミングの基本作法</strong>:<ul>
<li><p><code>Hello, World!</code>: コンソール (<code>console.log(&quot;Hello, World!&quot;);</code>) とブラウザ表示 (<code>alert(&quot;Hello, World!&quot;);</code> またはDOM操作で)。</p>
<ul>
<li><p><strong>HTML連携例</strong>:</p>
<pre><code class="language-html">// filepath: (第1章のHTML連携例)
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;&lt;title&gt;JS Test&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
  &lt;p id=&quot;message&quot;&gt;こんにちは&lt;/p&gt;
  &lt;button onclick=&quot;changeMessage()&quot;&gt;メッセージ変更&lt;/button&gt;
  &lt;script&gt;
    function changeMessage() {
      document.getElementById(&#39;message&#39;).textContent = &#39;JavaScriptで変更しました！&#39;;
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
</ul>
</li>
<li><p>コメント: <code>// 一行コメント</code>, <code>/* 複数行コメント */</code>。</p>
</li>
<li><p>セミコロン: ASI (Automatic Semicolon Insertion) の挙動と注意点。</p>
<ul>
<li><p><strong>ASIバグ例</strong>:</p>
<pre><code class="language-javascript">// filepath: (第1章の説明箇所)
function getObject() {
  return // ASIによりここでセミコロンが挿入される
  {
    name: &quot;ASI Trap&quot;
  }
}
console.log(getObject()); // undefined になる！
</code></pre>
<p>  「ASIは便利な反面、意図しない挙動も。チームのスタイルガイドに従うのが賢明です。」</p>
</li>
</ul>
</li>
<li><p>波括弧 <code>{}</code>: ブロックを示す、オブジェクトリテラルで使う。</p>
</li>
</ul>
</li>
<li><strong>「オブジェクトという便利な箱」の具体性</strong>: 「名前（プロパティ）とそれに対応する値や機能（メソッド）をまとめて管理できる、整理整頓された引き出しのようなもの。」</li>
</ol>
</li>
</ul>
<h4>第2章: 変数とデータ型 – 情報の入れ物と種類</h4>
<ul>
<li><strong>目的</strong>: データを格納する変数、データの種類（データ型）、変数が有効な範囲（スコープ）、型変換の基本を理解する。</li>
<li><strong>内容</strong>:<ol>
<li><strong>変数</strong>: データに名前を付ける。<ul>
<li><code>var</code>: 歴史的経緯と問題点（関数スコープ、巻き上げ）。基本的に使わない。</li>
<li><code>let</code>: 再代入可能な変数を宣言（ブロックスコープ）。</li>
<li><code>const</code>: 再代入不可能な変数を宣言（ブロックスコープ）。基本的にこちらを推奨。<ul>
<li><strong>オブジェクト/配列の場合</strong>: 「<code>const user = {name: &#39;Alice&#39;}; user.name = &#39;Bob&#39;;</code> はOK（箱の中身は変えられる）。でも <code>user = {name: &#39;Charlie&#39;};</code> はNG（箱自体を別のものに入れ替えるのはダメ）。変数が指し示すメモリアドレスが固定される。」図解推奨。</li>
</ul>
</li>
<li>宣言と代入。</li>
</ul>
</li>
<li><strong>データ型</strong>:<ul>
<li>プリミティブ型:<ul>
<li><code>string</code> (文字列): <code>&#39;hello&#39;</code>, <code>&quot;world&quot;</code>, <code>`template literal`</code></li>
<li><code>number</code> (数値): <code>123</code>, <code>3.14</code>, <code>NaN</code>, <code>Infinity</code></li>
<li><code>boolean</code> (真偽値): <code>true</code>, <code>false</code></li>
<li><code>null</code>: 「意図的に値がないことを示す」特別な値。<ul>
<li>具体例: 「DOM要素の取得に失敗した場合（例: <code>document.getElementById(&#39;存在しないID&#39;)</code>）」「開発者が意図的に『値がない』ことを示すために代入する場合」。</li>
</ul>
</li>
<li><code>undefined</code>: 「値がまだ代入されていない」状態。<ul>
<li>具体例: 「関数の引数が渡されなかった場合」「オブジェクトに存在しないプロパティにアクセスしようとした場合」「変数を宣言したが値を代入していない場合」。</li>
</ul>
</li>
<li><code>symbol</code>: (ES6+) 一意で不変な値。オブジェクトプロパティのキーとして衝突を避ける。<ul>
<li>ユースケース: <code>const RED = Symbol(&#39;赤&#39;);</code> 列挙型のような使い方、<code>Symbol.iterator</code>など既知のシンボル。</li>
</ul>
</li>
<li><code>bigint</code>: (ES2020+) <code>Number</code>で表現できない大きな整数。金融計算、暗号処理など。<code>123n</code>。</li>
</ul>
</li>
<li>オブジェクト型: プリミティブ型以外のデータ（配列、関数、オブジェクトなど）。</li>
</ul>
</li>
<li><strong>データ型の確認</strong>:<ul>
<li><code>typeof</code>演算子: <code>typeof 123</code> → <code>&quot;number&quot;</code>。<ul>
<li>注意点: <code>typeof null</code> → <code>&quot;object&quot;</code> (歴史的経緯)。<code>typeof []</code> → <code>&quot;object&quot;</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>スコープ</strong>: 変数が有効な範囲。<ul>
<li>グローバルスコープ: スクリプト全体からアクセス可能。</li>
<li>関数スコープ: 関数内でのみ有効 (<code>var</code>で宣言された変数)。</li>
<li>ブロックスコープ: <code>{}</code>ブロック内でのみ有効 (<code>let</code>, <code>const</code>で宣言された変数)。<ul>
<li><strong>図解</strong>: グローバルスコープを一番外側の大きな箱、関数スコープをその中の箱、ブロックスコープをさらにその中の小さな箱として描き、変数がどの箱から見えるかを示す。</li>
</ul>
</li>
</ul>
</li>
<li><strong>変数の巻き上げ (Hoisting)</strong>:<ul>
<li><code>var</code>: 宣言のみがスコープの先頭に巻き上げられる（初期値は<code>undefined</code>）。</li>
<li><code>let</code>/<code>const</code>: 宣言は巻き上げられるが、初期化されるまではTDZ (Temporal Dead Zone) にありアクセス不可（<code>ReferenceError</code>）。<ul>
<li>コード例: <code>console.log(a); var a = 1;</code> (undefined) vs <code>console.log(b); let b = 1;</code> (Error)。</li>
</ul>
</li>
</ul>
</li>
<li><strong>型変換</strong>:<ul>
<li>明示的型変換: <code>String()</code>, <code>Number()</code>, <code>Boolean()</code>, <code>parseInt()</code>, <code>parseFloat()</code>。</li>
<li>暗黙的型変換: 演算子 (<code>+</code>, <code>==</code>など) によって自動的に行われる変換。<ul>
<li>注意点: <code>1 + &quot;2&quot;</code> → <code>&quot;12&quot;</code>, <code>&#39;5&#39; - 1</code> → <code>4</code>。</li>
<li>トリッキーな例: <code>true + false</code> → <code>1</code>, <code>[] + {}</code> → <code>&quot;[object Object]&quot;</code>。</li>
<li>「JavaScriptは賢く型を推測しようとしますが、時にはおせっかいなことも。意図しない型変換に注意し、明示的な変換を心がけましょう。」</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4>第3章: 演算子と基本的なデータ構造 – 計算、比較、そして情報の集まり</h4>
<ul>
<li><strong>目的</strong>: 計算や比較を行う演算子、複数のデータをまとめて扱う配列とオブジェクトの基本的な使い方を習得する。</li>
<li><strong>内容</strong>:<ol>
<li><strong>演算子</strong>:<ul>
<li>算術演算子: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> (剰余), <code>**</code> (べき乗), <code>++</code> (インクリメント), <code>--</code> (デクリメント)。</li>
<li>比較演算子: <code>==</code> (等価), <code>===</code> (厳密等価), <code>!=</code> (不等価), <code>!==</code> (厳密不等価), <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>。<ul>
<li><code>===</code> と <code>!==</code> の使用を強く推奨。</li>
</ul>
</li>
<li>論理演算子: <code>&amp;&amp;</code> (論理AND), <code>||</code> (論理OR), <code>!</code> (論理NOT)。<ul>
<li><strong>ショートサーキット評価</strong>: <code>const name = user &amp;&amp; user.profile &amp;&amp; user.profile.name;</code>, <code>const displayName = preferredName || defaultName || &#39;Guest&#39;;</code></li>
</ul>
</li>
<li>代入演算子: <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>**=</code>.</li>
<li>三項演算子 (条件演算子): <code>条件 ? trueの場合の値 : falseの場合の値</code>。</li>
<li><strong>(参考) ビット演算子</strong>: この段階では深入り不要。</li>
<li><strong>演算子の優先順位と結合規則</strong>: 「複雑な式では括弧 <code>()</code> を使って計算順序を明示するのが安全で読みやすいコードのコツです。」MDNへのリンク。</li>
</ul>
</li>
<li><strong>コレクション型①: 配列 (<code>Array</code>)</strong>: 順序付けられた値のリスト。<ul>
<li>作成: <code>const arr = [1, &quot;apple&quot;, true];</code>, <code>new Array()</code>.</li>
<li>要素へのアクセス: インデックス (0から始まる)。<code>arr[0]</code>。</li>
<li>長さ: <code>arr.length</code>。</li>
<li>基本的な配列メソッド:<ul>
<li><code>push()</code>: 末尾に追加 (破壊的、新しい長さを返す)。</li>
<li><code>pop()</code>: 末尾を削除 (破壊的、削除した要素を返す)。</li>
<li><code>shift()</code>: 先頭を削除 (破壊的、削除した要素を返す)。</li>
<li><code>unshift()</code>: 先頭に追加 (破壊的、新しい長さを返す)。</li>
<li><code>slice(start, end)</code>: 部分配列を返す (非破壊的)。</li>
<li><code>splice(start, deleteCount, ...items)</code>: 要素を置換/削除/追加 (破壊的、削除した要素の配列を返す)。</li>
<li><strong>破壊的/非破壊的の明記とアイコン表示推奨。</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>コレクション型②: オブジェクト (<code>Object</code>)</strong>: 名前付きプロパティの集まり。<ul>
<li>オブジェクトとは: キー (文字列またはSymbol) と値のペア。データと機能をまとめる箱。</li>
<li>作成: <code>const obj = { key1: &quot;value1&quot;, &quot;two words&quot;: 2 };</code>, <code>new Object()</code>.</li>
<li>プロパティへのアクセス:<ul>
<li>ドット記法: <code>obj.key1</code> (キーが有効な識別子の場合)。</li>
<li>ブラケット記法: <code>obj[&quot;two words&quot;]</code>。<ul>
<li><strong>有用な場合</strong>: プロパティ名が変数 (<code>const prop = &quot;key1&quot;; obj[prop]</code>)、スペースやハイフンを含む、数値で始まる場合。動的プロパティ名 (<code>obj[&#39;prop&#39; + i] = val;</code>)。</li>
</ul>
</li>
</ul>
</li>
<li>プロパティの追加・変更: <code>obj.newKey = &quot;newValue&quot;;</code>, <code>obj.key1 = &quot;updatedValue&quot;;</code>.</li>
<li>プロパティの削除: <code>delete obj.key1;</code>.</li>
<li><strong><code>in</code>演算子と<code>hasOwnProperty</code></strong>:<ul>
<li><code>&#39;key1&#39; in obj</code>: プロトタイプチェーンも辿って存在確認。</li>
<li><code>obj.hasOwnProperty(&#39;key1&#39;)</code>: オブジェクト自身のプロパティか確認。</li>
</ul>
</li>
<li><strong>オブジェクトの比較</strong>: <code>{} === {}</code> は <code>false</code> (参照の比較)。プリミティブ型との違い。</li>
</ul>
</li>
<li><strong>オブジェクトの「機能」: メソッド入門</strong>:<ul>
<li><p>プロパティに関数を格納することで、オブジェクトが「振る舞い」を持つ。</p>
</li>
<li><p>例:</p>
<pre><code class="language-javascript">// filepath: (第3章の説明箇所)
let user = {
  name: &quot;高専太郎&quot;,
  greet: function() {
    // 「this」については、ここでは「このオブジェクト自身」くらいの簡単な説明に留める
    console.log(&quot;こんにちは、&quot; + this.name + &quot;さん！&quot;);
  }
};
user.greet(); // メソッド呼び出し
</code></pre>
<p>  「この<code>this.name</code>の<code>this</code>は、今まさに<code>greet</code>メソッドを呼び出している<code>user</code>オブジェクト自身のことを指しています。まるで、メソッドが『ご主人様！』と呼びかけているようなイメージですね。ただし、この<code>this</code>は時々気まぐれで、違うご主人様を指してしまうこともあるので、そのお話はまた後でじっくりと。」</p>
</li>
<li><p><code>console.log()</code> も <code>console</code> オブジェクトの <code>log</code> メソッド。</p>
</li>
</ul>
</li>
<li><strong>演習例</strong>: 「自己紹介するパーソンオブジェクト」<ul>
<li>初期状態: <code>name</code>, <code>age</code> プロパティと <code>greet</code> メソッドを持つ。</li>
<li>発展1: <code>addSkill(skillName)</code> メソッドを追加し、<code>skills</code> 配列プロパティにスキルを追加。</li>
<li>発展2: <code>introduceSkills()</code> メソッドを追加し、スキルを列挙して自己紹介。</li>
<li>発展3: <code>setAge(newAge)</code> メソッドを追加し、年齢を更新。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4>第4章: 制御フロー – プログラムの流れを操る</h4>
<ul>
<li><strong>目的</strong>: 条件に応じて処理を分岐させたり、特定の処理を繰り返したりする方法を習得する。</li>
<li><strong>内容</strong>:<ol>
<li><p><strong>条件分岐</strong>:</p>
<ul>
<li><p><code>if...else if...else</code> 文。</p>
</li>
<li><p><code>switch</code> 文:</p>
<ul>
<li><p><code>case</code> と <code>break</code>。<code>break</code> を忘れるとフォールスルーする点に注意。</p>
</li>
<li><p>意図的なフォールスルーの例:</p>
<pre><code class="language-javascript">// filepath: (第4章の説明箇所)
let message = &#39;&#39;;
const rank = &#39;gold&#39;;
switch (rank) {
  case &#39;platinum&#39;: message += &#39;プラチナ特典利用可能。&#39;; // breakなし
  case &#39;gold&#39;:   message += &#39;ゴールド特典利用可能。&#39;; // breakなし
  case &#39;silver&#39;: message += &#39;シルバー特典利用可能。&#39;; break;
  default: message = &#39;通常会員特典のみ利用可能。&#39;;
}
// rankが&#39;gold&#39;なら &quot;ゴールド特典利用可能。シルバー特典利用可能。&quot;
</code></pre>
</li>
</ul>
</li>
<li><p>三項演算子 (条件演算子): <code>条件 ? trueの場合の値 : falseの場合の値</code>。</p>
</li>
<li><p><strong>注意点</strong>: 可読性が低下する場合があるので、複雑な条件分岐には <code>if...else</code> を使用。</p>
</li>
</ul>
</li>
<li><p><strong>繰り返し処理 (ループ)</strong>: フローチャートのような視覚的表現も活用。</p>
<ul>
<li><code>for</code> ループ: <code>for (初期化; 条件; 更新) { ... }</code>。</li>
<li><code>while</code> ループ: <code>while (条件) { ... }</code>。</li>
<li><code>do...while</code> ループ: <code>do { ... } while (条件);</code> (最低1回は実行)。</li>
<li><strong>無限ループの危険性</strong>: ブラウザがフリーズする <code>while(true){}</code> の例（コメントアウト推奨）。Node.jsなら<code>Ctrl+C</code>、ブラウザならタスクマネージャーで強制終了。</li>
</ul>
</li>
<li><p><strong>ループの制御</strong>:</p>
<ul>
<li><code>break</code>: ループを完全に抜ける。</li>
<li><code>continue</code>: 現在の反復処理をスキップし、次の反復へ進む。</li>
<li><strong>ラベル付きステートメント</strong>: ネストしたループから一気に抜けたい場合（高度なため、存在を示唆する程度。「こんなこともできるんだ、くらいに留めておきましょう」）。</li>
</ul>
</li>
<li><p><strong>コレクションとループ</strong>:</p>
<ul>
<li><p><code>for...in</code> ループ: オブジェクトのプロパティを列挙。</p>
<ul>
<li><p><strong>配列には非推奨</strong>: プロトタイプチェーン上のプロパティも列挙する可能性、順序保証なし。</p>
</li>
<li><p>失敗例:</p>
<pre><code class="language-javascript">// filepath: (第4章の説明箇所)
Array.prototype.customProperty = &quot;これは罠だ！&quot;;
const arr = [10, 20, 30];
for (const i in arr) { // i は文字列の &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;customProperty&quot;
  if (arr.hasOwnProperty(i)) { // 自衛策
     console.log(`Index: ${i}, Value: ${arr[i]}`);
  }
}
delete Array.prototype.customProperty;
</code></pre>
</li>
</ul>
</li>
<li><p><code>for...of</code> ループ (ES6+): イテラブルオブジェクト (配列、文字列、Map, Setなど) の要素を列挙。</p>
<ul>
<li>文字列の例: <code>for (const char of &quot;こんにちは&quot;) { console.log(char); }</code> (サロゲートペアも正しく扱える)。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>演習例</strong>: FizzBuzz問題、配列要素の合計計算など。</p>
</li>
</ol>
</li>
</ul>
<h4>第5章: 関数とスコープ、エラー処理 – 処理の部品化とその周辺知識</h4>
<ul>
<li><strong>目的</strong>: 処理を部品化する関数を深く学び、関数がJavaScriptにおいて特別なオブジェクトであること、スコープの概念、エラー発生時の対処法を理解する。</li>
<li><strong>内容</strong>:<ol>
<li><strong>関数</strong>: 処理をまとめる。<ul>
<li>関数宣言: <code>function myFunction(param1, param2) { /*処理*/ return result; }</code></li>
<li>関数式: <code>const myFunction = function(param1, param2) { /*処理*/ return result; };</code></li>
<li>アロー関数 (ES6+): <code>const myFunction = (param1, param2) =&gt; { /*処理*/ return result; };</code><ul>
<li><code>const myFunction = (param1, param2) =&gt; result;</code> (暗黙のreturn)</li>
<li><code>const createObj = () =&gt; ({ key: &#39;value&#39; });</code> (オブジェクトリテラルを返す場合)</li>
</ul>
</li>
<li>引数 (parameters)、戻り値 (<code>return</code>)。</li>
<li><strong>デフォルト引数 (ES6+)</strong>: <code>function greet(name = &quot;Guest&quot;) { ... }</code></li>
<li><strong>レストパラメータ (ES6+)</strong>: <code>function sum(...numbers) { return numbers.reduce((acc, num) =&gt; acc + num, 0); }</code></li>
</ul>
</li>
<li><strong>アロー関数と従来の関数の主な違い</strong>: 比較表とコード例で示す。<ul>
<li>巻き上げ: 関数宣言は巻き上げられる、関数式/アロー関数は変数と同様。</li>
<li><code>this</code>の挙動: レキシカル<code>this</code> (アロー関数) vs 呼び出し方で決まる<code>this</code> (従来関数)。</li>
<li><code>arguments</code>オブジェクト: アロー関数は持たない (レストパラメータで代替)。</li>
<li><code>new</code>演算子: アロー関数はコンストラクタになれない。</li>
<li><code>prototype</code>プロパティ: アロー関数は持たない。</li>
</ul>
</li>
<li><strong>関数の正体: 関数は特別なオブジェクト！</strong><ul>
<li><p>導入: 「実は、今まで使ってきた関数も、JavaScriptの世界では『オブジェクト』の一種なんだ。」</p>
</li>
<li><p>関数もプロパティを持てる:</p>
<pre><code class="language-javascript">// filepath: (第5章の説明箇所)
function calculateArea(width, height) {
  if (calculateArea.callCount === undefined) calculateArea.callCount = 0;
  calculateArea.callCount++;
  return width * height;
}
calculateArea.description = &quot;長方形の面積を計算する関数です。&quot;;
console.log(calculateArea(10,5), calculateArea.description, calculateArea.callCount);
</code></pre>
</li>
<li><p>関数は変数に代入できる (第一級オブジェクトの再確認)。</p>
</li>
<li><p>関数を他の関数の引数に渡せる (コールバック関数の基礎)。</p>
</li>
<li><p>関数を他の関数の戻り値にできる (クロージャの基礎)。</p>
</li>
<li><p><code>typeof</code>演算子の挙動: <code>typeof myFunction</code> が <code>&quot;function&quot;</code> を返すのは、それが「呼び出し可能なオブジェクト」だから。「内部的に[[Call]]という特別な仕組みを持っている、とだけ覚えておけばOKです。」</p>
</li>
</ul>
</li>
<li><strong>スコープ (再確認と深掘り)</strong>:<ul>
<li><p>グローバルスコープ、関数スコープ、ブロックスコープ。</p>
</li>
<li><p><strong>レキシカルスコープ (静的スコープ)</strong>: 関数が定義された場所でスコープが決まる。</p>
<pre><code class="language-javascript">// filepath: (第5章の説明箇所)
let x = &quot;global_x&quot;; let y = &quot;global_y&quot;;
function outerFunc() {
  let x = &quot;outer_x&quot;;
  function innerFunc() {
    let x = &quot;inner_x&quot;;
    console.log(&quot;innerFunc sees x as: &quot; + x); // inner_x
    console.log(&quot;innerFunc sees y as: &quot; + y); // global_y
  }
  return innerFunc;
}
const myInnerFunc = outerFunc(); myInnerFunc();
</code></pre>
<p>  「関数<code>innerFunc</code>は、それが定義された場所（<code>outerFunc</code>の中）の『空気』（スコープ）を覚えています。」</p>
</li>
</ul>
</li>
<li><strong>即時実行関数 (IIFE)</strong>: <code>(function() { ... })();</code><ul>
<li>目的: プライベートスコープの作成、グローバル汚染の防止 (歴史的経緯として)。</li>
</ul>
</li>
<li><strong>エラーハンドリング</strong>:<ul>
<li><p><code>try...catch...finally</code> 構文:</p>
<ul>
<li><p><code>try</code>: エラーが発生する可能性のあるコード。</p>
</li>
<li><p><code>catch (error)</code>: エラー発生時の処理。<code>error</code>オブジェクト (<code>error.name</code>, <code>error.message</code>)。</p>
</li>
<li><p><code>finally</code>: 成功/失敗に関わらず必ず実行される処理 (リソース解放など)。</p>
<pre><code class="language-javascript">// filepath: (第5章の説明箇所)
let resourceBusy = false;
try {
  resourceBusy = true; /* リソース使用開始 */
  // if (Math.random() &lt; 0.5) throw new Error(&quot;処理中に問題発生！&quot;);
} catch (e) {
  console.error(&quot;エラー: &quot; + e.message);
} finally {
  resourceBusy = false; /* リソース解放 */
  console.log(&quot;リソース解放完了。busy: &quot; + resourceBusy);
}
</code></pre>
</li>
</ul>
</li>
<li><p><code>throw new Error(&#39;メッセージ&#39;)</code>: 意図的にエラーを発生させる。</p>
</li>
<li><p><strong>エラーオブジェクトの種類</strong>: <code>Error</code> (汎用), <code>TypeError</code> (型不正), <code>SyntaxError</code> (文法ミス), <code>ReferenceError</code> (未定義変数参照), <code>RangeError</code> (数値範囲外), <code>URIError</code> (URI関連)。それぞれが発生する短いコード例。</p>
</li>
</ul>
</li>
<li><strong>高階関数への再言及</strong>: 関数がオブジェクトであることのメリットとして、コールバック関数や関数を返す関数（クロージャの応用）の例を再度示し、後の非同期処理や配列操作への繋がりを意識させる。</li>
</ol>
</li>
</ul>
<hr>
<h3>第2部: ブラウザとJavaScript – ウェブページを動かす</h3>
<h4>第6章: DOMの探求 – HTMLをJavaScriptで操る</h4>
<ul>
<li><strong>目的</strong>: DOMの概念を深く理解し、HTML要素の取得、内容変更、属性・スタイル操作、動的な要素の追加・削除といった基本的なDOM操作を習得する。</li>
<li><strong>内容</strong>:<ol>
<li><p><strong>DOM (Document Object Model) とは</strong>:</p>
<ul>
<li>HTML/XML文書をオブジェクトのツリー構造として表現するAPI。</li>
<li><strong>図解</strong>: HTMLのネスト構造とDOMツリーの対応関係。開発者ツールの要素タブがDOMツリーの可視化であることを示す。</li>
<li><code>document</code>オブジェクト: DOMツリーの入り口。<code>document.title</code>, <code>document.URL</code>など。</li>
</ul>
</li>
<li><p><strong>DOM要素の取得</strong>:</p>
<ul>
<li><code>document.getElementById(&#39;id&#39;)</code>: 特定のIDを持つ要素 (単一)。</li>
<li><code>document.getElementsByTagName(&#39;tag&#39;)</code>: 指定タグ名の要素群 (<code>HTMLCollection</code> - ライブ)。</li>
<li><code>document.getElementsByClassName(&#39;class&#39;)</code>: 指定クラス名の要素群 (<code>HTMLCollection</code> - ライブ)。</li>
<li><code>document.querySelector(&#39;selector&#39;)</code>: CSSセレクタに一致する最初の要素 (単一 - 静的)。</li>
<li><code>document.querySelectorAll(&#39;selector&#39;)</code>: CSSセレクタに一致する全要素 (<code>NodeList</code> - 静的)。</li>
<li><strong>ライブコレクション vs 静的コレクション</strong>:<ul>
<li><p><code>HTMLCollection</code> (ライブ): DOMの変更が即座に反映される。</p>
</li>
<li><p><code>NodeList</code> (静的、<code>querySelectorAll</code>の場合): 取得時点のスナップショット。</p>
</li>
<li><p>問題点: ループ中にDOM変更を行う場合、ライブコレクションはインデックスずれや無限ループの危険性。</p>
<pre><code class="language-javascript">// filepath: (第6章の説明箇所)
// ライブコレクションの問題例
const listItemsLive = document.getElementsByTagName(&#39;li&#39;);
for (let i = 0; i &lt; listItemsLive.length; i++) { /* 削除するとlengthが変わり問題発生しうる */ }
// 静的コレクションなら安全
const listItemsStatic = document.querySelectorAll(&#39;li&#39;);
listItemsStatic.forEach(item =&gt; { /* item.remove() */ });
</code></pre>
</li>
<li><p>判断基準: 「常に最新のDOM状態を反映させたい場合はライブ、ループ処理などで安全に扱いたい場合は静的（または<code>Array.from()</code>で配列化）が良いでしょう。」</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>ノードの種類</strong>: 要素ノード、テキストノード、コメントノードなど。</p>
<ul>
<li><code>element.childNodes</code> (テキストノード等も含むNodeList) vs <code>element.children</code> (要素ノードのみのHTMLCollection)。</li>
</ul>
</li>
<li><p><strong>DOM要素の内容変更</strong>:</p>
<ul>
<li><code>element.textContent</code>: テキスト内容のみ (安全、推奨)。</li>
<li><code>element.innerHTML</code>: HTML構造を含む内容 (XSSリスクあり)。<ul>
<li><p><strong>XSSデモ</strong>:</p>
<pre><code class="language-html">// filepath: (第6章のHTML連携例)
&lt;div id=&quot;target&quot;&gt;&lt;/div&gt; &lt;input id=&quot;userInput&quot;&gt;
&lt;button onclick=&quot;document.getElementById(&#39;target&#39;).innerHTML = document.getElementById(&#39;userInput&#39;).value;&quot;&gt;innerHTML更新&lt;/button&gt;
&lt;button onclick=&quot;document.getElementById(&#39;target&#39;).textContent = document.getElementById(&#39;userInput&#39;).value;&quot;&gt;textContent更新&lt;/button&gt;
&lt;!-- userInputに &lt;img src=&quot;x&quot; onerror=&quot;alert(&#39;XSS!&#39;)&quot;&gt; と入力 --&gt;
</code></pre>
<p>  「ユーザー入力内容を<code>innerHTML</code>に使うのは危険。原則<code>textContent</code>を。」</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>DOM要素の属性操作</strong>:</p>
<ul>
<li><code>element.getAttribute(&#39;attrName&#39;)</code></li>
<li><code>element.setAttribute(&#39;attrName&#39;, &#39;value&#39;)</code></li>
<li><code>element.removeAttribute(&#39;attrName&#39;)</code></li>
<li><strong>データ属性 (<code>data-*</code>)</strong>: <code>element.dataset.customName</code> (HTML: <code>data-custom-name</code>)。JavaScriptからHTML要素に追加情報を紐付ける。</li>
</ul>
</li>
<li><p><strong>DOM要素のスタイル操作</strong>:</p>
<ul>
<li><code>element.style.property</code>: <code>element.style.color = &#39;red&#39;;</code> (インラインスタイル)。<ul>
<li>非推奨理由: CSSの詳細度で最強になり管理が困難。保守性低下。クラス付け外しを推奨。</li>
</ul>
</li>
<li><code>element.classList</code>: <code>add()</code>, <code>remove()</code>, <code>toggle()</code>, <code>contains()</code>。<ul>
<li><p><code>toggle</code>実践例: ダークモード切り替え。</p>
<pre><code class="language-javascript">// filepath: (第6章のスクリプト箇所)
const toggleBtn = document.getElementById(&#39;darkModeToggle&#39;);
if (toggleBtn) toggleBtn.addEventListener(&#39;click&#39;, () =&gt; document.body.classList.toggle(&#39;dark-mode&#39;));
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>DOM要素の動的変更</strong>:</p>
<ul>
<li>作成: <code>document.createElement(&#39;tagName&#39;)</code></li>
<li>追加: <code>parentElement.appendChild(newChild)</code>, <code>parentElement.insertBefore(newNode, referenceNode)</code> (<code>referenceNode</code>が<code>null</code>なら<code>appendChild</code>と同じ)。</li>
<li>置換: <code>parentElement.replaceChild(newChild, oldChild)</code></li>
<li>削除: <code>childElement.remove()</code> (モダン), <code>parentElement.removeChild(childElement)</code> (旧)。</li>
<li>クローン: <code>element.cloneNode(deep)</code> (<code>deep=true</code>で子孫もコピー、<code>false</code>なら自身のみ。イベントリスナーはコピーされない)。</li>
</ul>
</li>
<li><p><strong>DOM操作のパフォーマンス</strong>:</p>
<ul>
<li>DocumentFragment: 複数の要素をまとめてDOMに追加し、再描画を抑制。</li>
<li>ループ外での要素参照保持。</li>
<li>CSS <code>display: none</code>の活用。</li>
</ul>
</li>
<li><p><strong>要素のサイズや位置の取得</strong>: <code>offsetWidth</code>, <code>offsetHeight</code>, <code>getBoundingClientRect()</code> (ビューポート相対位置と寸法)。</p>
</li>
<li><p><strong>演習例</strong>: 「ボタンクリックで新しいリストアイテムが追加・削除される」機能の実装。</p>
</li>
</ol>
</li>
</ul>
<h4>第7章: JavaScriptイベント処理 – ユーザーとの対話</h4>
<ul>
<li><strong>目的</strong>: ユーザーのアクションやブラウザの出来事（イベント）を捉え、それに応じた処理を実行する方法を深く学ぶ。</li>
<li><strong>内容</strong>:<ol>
<li><p><strong>イベントとは</strong>: クリック、キー入力、マウス操作、ページの読み込み完了など。</p>
<ul>
<li><strong>代表的なイベント例と用途</strong>:<ul>
<li>マウス: <code>click</code>, <code>dblclick</code>, <code>mousedown</code>, <code>mouseup</code>, <code>mousemove</code>, <code>mouseover</code>/<code>mouseout</code> (バブリングあり), <code>mouseenter</code>/<code>mouseleave</code> (バブリングなし)。</li>
<li>キーボード: <code>keydown</code>, <code>keyup</code> (<code>keypress</code>は非推奨)。<code>event.key</code>, <code>event.code</code>の違い。</li>
<li>フォーム: <code>submit</code> (フォーム送信時), <code>change</code> (入力内容変更完了時), <code>input</code> (入力内容変更中)。</li>
<li>ウィンドウ/ドキュメント: <code>load</code> (全リソース読込完了), <code>DOMContentLoaded</code> (DOM構築完了), <code>resize</code>, <code>scroll</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>イベントリスナーの登録と解除</strong>:</p>
<ul>
<li><code>element.addEventListener(&#39;eventName&#39;, callbackFunction, options)</code>: 推奨。<ul>
<li><code>options</code>: <code>{ capture?: boolean, once?: boolean, passive?: boolean }</code></li>
</ul>
</li>
<li><code>element.removeEventListener(&#39;eventName&#39;, callbackFunction, options)</code>: メモリリーク防止に重要。登録時と同じ参照の関数が必要。</li>
<li>旧来の方法 (<code>on&lt;event&gt;</code>属性, <code>element.onevent = handler</code>) は非推奨。</li>
</ul>
</li>
<li><p><strong>イベントオブジェクト (<code>event</code>)</strong>: イベント発生時の情報を持つ。</p>
<ul>
<li><p><code>event.target</code>: 実際にイベントが発生した要素。</p>
</li>
<li><p><code>event.currentTarget</code>: イベントリスナーが登録された要素。</p>
<ul>
<li><p>違いの具体例:</p>
<pre><code class="language-html">// filepath: (第7章のHTML連携例)
&lt;ul id=&quot;parent-list&quot;&gt;&lt;li&gt;アイテム 1 &lt;button&gt;削除&lt;/button&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;script&gt;
  // filepath: (第7章のスクリプト箇所)
  document.getElementById(&#39;parent-list&#39;).addEventListener(&#39;click&#39;, function(event) {
    console.log(&#39;currentTarget:&#39;, event.currentTarget); // &lt;ul&gt;
    console.log(&#39;target:&#39;, event.target);       // &lt;li&gt; or &lt;button&gt;
  });
&lt;/script&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><code>event.preventDefault()</code>: デフォルト動作をキャンセル (例: <code>&lt;a&gt;</code>タグの画面遷移、フォームの送信)。</p>
</li>
<li><p><code>event.stopPropagation()</code>: イベントの伝播を止める。</p>
</li>
</ul>
</li>
<li><p><strong>イベント伝播</strong>:</p>
<ul>
<li>キャプチャリングフェーズ: ルートからターゲットへ。</li>
<li>ターゲットフェーズ: ターゲット要素で発火。</li>
<li>バブリングフェーズ: ターゲットからルートへ。</li>
<li>図解推奨。<code>addEventListener</code>の第3引数 <code>{ capture: true }</code> でキャプチャリングフェーズで補足。</li>
</ul>
</li>
<li><p><strong>イベントデリゲーション</strong>: 親要素にイベントリスナーを一つ登録し、<code>event.target</code>で処理を振り分ける。</p>
<ul>
<li><p>メリット: 動的に追加される要素にも対応、リスナー数の削減。</p>
</li>
<li><p>具体例 (TODOリストの削除ボタン):</p>
<pre><code class="language-javascript">// filepath: (第7章のスクリプト箇所)
todoListElement.addEventListener(&#39;click&#39;, function(event) {
  if (event.target.classList.contains(&#39;delete-button&#39;)) {
    event.target.closest(&#39;li&#39;).remove();
  }
});
</code></pre>
</li>
</ul>
</li>
<li><p><strong>イベントリスナー内での <code>this</code></strong>:</p>
<ul>
<li><p>通常の関数: <code>this</code> は <code>event.currentTarget</code> (イベントリスナーが登録された要素) を指す。</p>
</li>
<li><p>アロー関数: <code>this</code> は外側のレキシカルスコープの <code>this</code> を維持する。</p>
<pre><code class="language-javascript">// filepath: (第7章のスクリプト箇所)
myButton.addEventListener(&#39;click&#39;, function() { console.log(this); /* myButton */ });
const obj = { method: function() { myButton.addEventListener(&#39;click&#39;, () =&gt; console.log(this)); /* obj */ }};
</code></pre>
</li>
</ul>
</li>
<li><p><strong>カスタムイベント</strong>: <code>new CustomEvent(&#39;eventName&#39;, { detail: data })</code> と <code>element.dispatchEvent(event)</code>。コンポーネント間の疎結合な連携。</p>
</li>
<li><p><strong>イベントの頻度制御 (発展)</strong>: <code>scroll</code>, <code>mousemove</code>など頻発イベントのパフォーマンス対策。</p>
<ul>
<li><code>debounce</code>: 一定時間イベントが来なければ実行。</li>
<li><code>throttle</code>: 一定時間ごとに一度だけ実行。 (概念紹介、実装は発展課題)</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4>第8章: ブラウザAPIの活用 – ストレージ、Cookie、その他</h4>
<ul>
<li><strong>目的</strong>: ブラウザが提供するデータ保存機能（Web Storage, Cookie）やその他の便利なAPIの基本を理解し、活用できるようになる。</li>
<li><strong>内容</strong>:<ol>
<li><strong>Web Storage API</strong>: クライアントサイドでのデータ保存。<ul>
<li><code>localStorage</code>: オリジン単位、永続的（ブラウザを閉じても残る）。</li>
<li><code>sessionStorage</code>: オリジン単位かつタブ/ウィンドウ単位、セッション中のみ（タブ/ウィンドウを閉じると消える）。</li>
<li><strong>比較</strong>: 永続性、スコープ、ユースケース（ユーザー設定 vs 一時的フォーム入力）。</li>
<li>API: <code>setItem(key, value)</code>, <code>getItem(key)</code>, <code>removeItem(key)</code>, <code>clear()</code>, <code>length</code>, <code>key(index)</code>。</li>
<li>注意点:<ul>
<li><p>文字列のみ保存可能: <code>JSON.stringify()</code> / <code>JSON.parse()</code> でオブジェクトを保存・復元。</p>
<pre><code class="language-javascript">// filepath: (第8章の説明箇所)
const settings = { theme: &#39;dark&#39; };
localStorage.setItem(&#39;settings&#39;, JSON.stringify(settings));
const loaded = JSON.parse(localStorage.getItem(&#39;settings&#39;));
</code></pre>
</li>
<li><p>保存容量制限 (通常5MB程度)。</p>
</li>
<li><p>同期API: 大量データの読み書きはUI応答性を損なう可能性。</p>
</li>
</ul>
</li>
<li><strong><code>Storage</code>イベント</strong>: <code>localStorage</code>/<code>sessionStorage</code>が別タブ/ウィンドウで変更された際に発火 (<code>window.addEventListener(&#39;storage&#39;, callback)</code>）。タブ間通信。</li>
</ul>
</li>
<li><strong>Cookie</strong>: サーバーとの通信で状態を維持。<ul>
<li>概要と用途: セッション管理、トラッキングなど。</li>
<li>仕組み: HTTPヘッダーで送受信。</li>
<li>属性:<ul>
<li><code>Expires</code>/<code>Max-Age</code>: 有効期限。</li>
<li><code>Domain</code>/<code>Path</code>: 送信範囲。</li>
<li><code>Secure</code>: HTTPS通信時のみ送信。</li>
<li><code>HttpOnly</code>: JavaScriptからのアクセス禁止 (XSS対策)。</li>
<li><code>SameSite</code> (<code>Strict</code>, <code>Lax</code>, <code>None</code>): CSRF対策。<code>None</code>の場合は<code>Secure</code>必須。</li>
<li>「これらの属性を適切に設定することがセキュリティ上非常に重要です。」</li>
</ul>
</li>
<li>JavaScriptからの操作: <code>document.cookie</code> (煩雑)。<ul>
<li>「通常はサーバーサイドで<code>Set-Cookie</code>ヘッダーで設定。クライアントでの複雑な操作はライブラリ検討。」</li>
</ul>
</li>
<li><strong>Web Storageとの使い分け</strong>: サーバー連携の要否、データサイズ、自動送受信の有無。</li>
<li><strong>プライバシー懸念</strong>: サードパーティCookieとトラッキング、ブラウザによる制限の動き。</li>
</ul>
</li>
<li><strong>IndexedDB (概要)</strong>: 大量で複雑な構造化データをクライアントに保存。<ul>
<li>特徴: 非同期API、トランザクション、インデックス。</li>
<li>localStorageとの使い分け: 大量データ、オフラインアプリの本格的データストア。</li>
</ul>
</li>
<li><strong>(発展) その他のブラウザAPI紹介</strong>:<ul>
<li>Geolocation API: 位置情報取得。</li>
<li>History API: ブラウザ履歴の操作 (SPAで活用)。</li>
<li>Web Workers: バックグラウンドスレッドで重い処理。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h3>第3部: 非同期処理と通信 – 時間のかかる処理との付き合い方</h3>
<h4>第9章: 非同期処理の仕組み – JavaScriptのシングルスレッドとイベントループ</h4>
<ul>
<li><strong>目的</strong>: JavaScriptがシングルスレッドでありながら、どのようにして時間のかかる処理（非同期処理）を効率的に扱っているのか、その核となるイベントループのメカニズムを理解する。</li>
<li><strong>内容</strong>:<ol>
<li><p><strong>JavaScriptはシングルスレッド</strong>:</p>
<ul>
<li>メリット: プログラムの実行順序が予測しやすい、競合状態の心配が少ない。</li>
<li>デメリット: 一つの処理が長引くと全体がブロックされる（UIフリーズなど）。</li>
</ul>
</li>
<li><p><strong>非同期処理とは？ なぜ必要か？</strong>:</p>
<ul>
<li><p>ブロッキングを防ぎ、応答性の高いUIを実現するため。</p>
</li>
<li><p>UIブロッキング例:</p>
<pre><code class="language-javascript">// filepath: (第9章のスクリプト箇所)
// blockingButtonクリックで5秒間UIが固まる処理
// nonBlockingButtonクリックでsetTimeoutを使い5秒後に処理完了、UIは固まらない
</code></pre>
<p>  「ブロッキング処理ボタンを押すと、5秒間は他の操作ができなくなるのを体験してみましょう。」</p>
</li>
</ul>
</li>
<li><p><strong>イベントループの構成要素と動作メカニズム</strong>:</p>
<ul>
<li>コールスタック: 実行中の関数を管理。</li>
<li>ヒープ: オブジェクトが格納されるメモリ領域。</li>
<li>Web API (ブラウザ環境) / C++ API (Node.js環境): <code>setTimeout</code>, DOMイベント, <code>fetch</code>などの非同期処理を実行する部分。JavaScriptエンジン外。</li>
<li>タスクキュー (マクロタスクキュー / コールバックキュー): Web APIでの処理完了後、実行されるべきコールバック関数が待機する場所。</li>
<li>マイクロタスクキュー: Promiseのコールバックなど、より優先度の高いタスクが待機する場所。</li>
<li>イベントループ: コールスタックが空の場合、タスクキュー/マイクロタスクキューからタスクを取り出しコールスタックに乗せる監視役。</li>
<li><strong>図解</strong>: Loupe (<a href="http://latentflip.com/loupe/">http://latentflip.com/loupe/</a>) のようなツールや、各要素と処理の流れを示した図で説明。</li>
</ul>
</li>
<li><p><strong><code>setTimeout(fn, 0)</code>の挙動</strong>:</p>
<ul>
<li>即時実行ではなく、タスクキュー経由でコールスタックが空になった後に実行される。</li>
<li>演習: <code>console.log(&#39;A&#39;); setTimeout(() =&gt; console.log(&#39;B&#39;), 0); console.log(&#39;C&#39;);</code> の出力順序予想 (A, C, B)。</li>
</ul>
</li>
<li><p><strong>マイクロタスク vs マクロタスク</strong>:</p>
<ul>
<li><p>マイクロタスク (<code>Promise.then</code>, <code>queueMicrotask</code>など) は、現在のマクロタスク完了後、次のマクロタスクの前にまとめて処理される。</p>
</li>
<li><p>具体例:</p>
<pre><code class="language-javascript">// filepath: (第9章のスクリプト箇所)
console.log(&#39;1: Script Start&#39;);
setTimeout(() =&gt; console.log(&#39;2: setTimeout (macro)&#39;), 0);
Promise.resolve().then(() =&gt; console.log(&#39;3: Promise (micro 1)&#39;))
                 .then(() =&gt; console.log(&#39;4: Promise (micro 2)&#39;));
console.log(&#39;5: Script End&#39;);
// 出力順: 1, 5, 3, 4, 2
</code></pre>
</li>
</ul>
</li>
<li><p><strong>レンダリングとの関連</strong>: イベントループはブラウザのレンダリング処理とも関連。重い同期処理はレンダリングもブロックするが、非同期処理の合間にレンダリングが行われる。</p>
</li>
</ol>
</li>
</ul>
<h4>第10章: PromiseとAsync/Await – モダンな非同期処理スタイル</h4>
<ul>
<li><strong>目的</strong>: 非同期処理をより構造化され、読みやすく記述するためのPromiseオブジェクトと、それをさらに直感的に扱えるAsync/Await構文を習得する。</li>
<li><strong>内容</strong>:<ol>
<li><p><strong>伝統的な非同期処理: コールバック関数 (再訪)</strong>:</p>
<ul>
<li><p><code>setTimeout</code>やイベントハンドラでの利用。</p>
</li>
<li><p>コールバック地獄 (Pyramid of Doom): ネストが深くなり可読性・保守性が低下する問題。</p>
<pre><code class="language-javascript">// filepath: (第10章の説明箇所 - コールバック地獄の例)
// asyncOperation1((err1, res1) =&gt; { asyncOperation2(res1, (err2, res2) =&gt; { ... }) });
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Promise</strong>: 非同期処理の最終的な結果を表すオブジェクト。</p>
<ul>
<li><p>状態: <code>pending</code> (待機中), <code>fulfilled</code> (成功), <code>rejected</code> (失敗)。一度状態が決まると変化しない。</p>
</li>
<li><p>Promiseコンストラクタ: <code>new Promise((resolve, reject) =&gt; { /* 非同期処理 */ if (success) resolve(value); else reject(error); })</code></p>
<ul>
<li><code>resolve(value)</code>: 成功を通知し、値を渡す。</li>
<li><code>reject(error)</code>: 失敗を通知し、エラーオブジェクトを渡す。</li>
</ul>
</li>
<li><p>インスタンスメソッド:</p>
<ul>
<li><code>.then(onFulfilled, onRejected)</code>: 成功時/失敗時のコールバックを登録。Promiseを返すためチェーン可能。</li>
<li><code>.catch(onRejected)</code>: 失敗時のコールバックのみ登録 (<code>.then(null, onRejected)</code>の糖衣構文)。</li>
<li><code>.finally(onFinally)</code>: 成功/失敗に関わらず実行されるコールバック。</li>
</ul>
</li>
<li><p>Promiseチェーン: コールバック地獄の解消。</p>
<pre><code class="language-javascript">// filepath: (第10章の説明箇所 - Promiseチェーンの例)
// promiseOperation1().then(res1 =&gt; promiseOperation2(res1)).then(res2 =&gt; ...).catch(err =&gt; ...);
</code></pre>
</li>
<li><p>静的メソッド:</p>
<ul>
<li><code>Promise.resolve(value)</code>: 即座に成功するPromiseを生成。</li>
<li><code>Promise.reject(error)</code>: 即座に失敗するPromiseを生成。</li>
<li><code>Promise.all(iterable)</code>: 全てのPromiseが成功したら成功。一つでも失敗したら失敗。並列処理。</li>
<li><code>Promise.race(iterable)</code>: 最初に成功または失敗したPromiseの結果を採用。タイムアウト処理など。</li>
<li><code>Promise.allSettled(iterable)</code> (ES2020): 全てのPromiseの結果（成功/失敗問わず）を配列で取得。</li>
<li><code>Promise.any(iterable)</code> (ES2021): 最初に成功したPromiseの結果を採用。全て失敗したら<code>AggregateError</code>で失敗。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Async/Await (ES2017)</strong>: Promiseを同期処理のように書ける糖衣構文。</p>
<ul>
<li><p><code>async</code>関数: 関数宣言の前に<code>async</code>を付けると、自動的にPromiseを返す関数になる。</p>
</li>
<li><p><code>await</code>演算子: <code>async</code>関数内でのみ使用可能。Promiseが解決されるまで処理を一時停止し、解決された値を返す。</p>
</li>
<li><p>エラーハンドリング: <code>try...catch</code>構文を使用。</p>
<pre><code class="language-javascript">// filepath: (第10章の説明箇所 - Async/Awaitの例)
async function fetchData() {
  try {
    const response = await fetch(&#39;url&#39;);
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error(&#39;エラー:&#39;, error);
  }
}
</code></pre>
</li>
<li><p><strong>演習</strong>: Promiseチェーンで書いた処理をAsync/Awaitでリファクタリング。</p>
</li>
</ul>
</li>
<li><p><strong>エラーハンドリングの深掘り</strong>: Promiseチェーンでのエラー伝播、<code>async/await</code>での複数<code>await</code>に対する<code>try...catch</code>の範囲。</p>
</li>
</ol>
</li>
</ul>
<h4>第11章: Fetch APIとデータ通信 – Webの情報を取得・送信する</h4>
<ul>
<li><strong>目的</strong>: 標準的な非同期通信手段であるFetch APIの使い方をマスターし、外部サーバーとJSON形式でデータをやり取りする方法、および関連するセキュリティ概念（CORS）を理解する。</li>
<li><strong>内容</strong>:<ol>
<li><p><strong>Fetch API</strong>: ブラウザ標準のHTTPリクエストAPI。Promiseベース。</p>
<ul>
<li>基本的な使い方: <code>fetch(url, options)</code><ul>
<li><code>url</code>: リクエスト先のURL。</li>
<li><code>options</code> (オブジェクト):<ul>
<li><code>method</code>: <code>&#39;GET&#39;</code> (デフォルト), <code>&#39;POST&#39;</code>, <code>&#39;PUT&#39;</code>, <code>&#39;DELETE&#39;</code>など。</li>
<li><code>headers</code>: <code>{&#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Bearer YOUR_TOKEN&#39;}</code>など。</li>
<li><code>body</code>: リクエストボディ。<code>POST</code>などで使用。<code>JSON.stringify({key: &#39;value&#39;})</code>。</li>
<li><code>mode</code>: <code>&#39;cors&#39;</code> (デフォルト), <code>&#39;no-cors&#39;</code>, <code>&#39;same-origin&#39;</code>。</li>
<li><code>credentials</code>: <code>&#39;include&#39;</code> (Cookie送信), <code>&#39;same-origin&#39;</code>, <code>&#39;omit&#39;</code> (デフォルト)。</li>
</ul>
</li>
</ul>
</li>
<li>レスポンスオブジェクト (<code>Response</code>):<ul>
<li><code>response.ok</code>: HTTPステータスが200-299なら<code>true</code>。</li>
<li><code>response.status</code>: HTTPステータスコード (例: 200, 404)。</li>
<li><code>response.statusText</code>: ステータスメッセージ (例: &quot;OK&quot;, &quot;Not Found&quot;)。</li>
<li><code>response.headers</code>: Headersオブジェクト。<code>response.headers.get(&#39;Content-Type&#39;)</code>などでヘッダー値取得。</li>
<li>ボディ処理メソッド (Promiseを返す):<ul>
<li><code>response.json()</code>: JSONとしてパース。</li>
<li><code>response.text()</code>: テキストとして取得。</li>
<li><code>response.blob()</code>: Blobオブジェクトとして取得 (画像など)。</li>
<li><code>response.formData()</code>: FormDataとして取得。</li>
<li><code>response.arrayBuffer()</code>: ArrayBufferとして取得。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Fetch APIにおけるエラーハンドリング</strong>:</p>
<ul>
<li><p>ネットワークエラー: <code>fetch()</code>自体が失敗する場合 (例: DNS解決不可、オフライン)。Promiseが<code>reject</code>され、<code>.catch()</code>で捕捉。</p>
</li>
<li><p>HTTPエラーステータス: 4xx, 5xxエラー。<code>fetch()</code>のPromiseはこれらでは<code>reject</code>されない。<code>response.ok</code>や<code>response.status</code>で判定が必要。</p>
<pre><code class="language-javascript">// filepath: (第11章のスクリプト箇所)
fetch(&#39;api/data&#39;)
  .then(response =&gt; {
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    return response.json();
  })
  .then(data =&gt; console.log(data))
  .catch(error =&gt; console.error(&#39;Fetchエラー:&#39;, error.message));
</code></pre>
</li>
</ul>
</li>
<li><p><strong>データの扱い: JSON (JavaScript Object Notation)</strong>:</p>
<ul>
<li><p><code>JSON.parse(jsonString)</code>: JSON文字列をJavaScriptオブジェクト/配列に変換。</p>
</li>
<li><p><code>JSON.stringify(jsObject)</code>: JavaScriptオブジェクト/配列をJSON文字列に変換。</p>
</li>
<li><p>演習: ネストしたJSONデータから特定情報を取り出す。</p>
<pre><code class="language-json">// filepath: (第11章の演習用JSONデータ例)
{ &quot;user&quot;: { &quot;name&quot;: &quot;高専花子&quot;, &quot;hobbies&quot;: [&quot;プログラミング&quot;, &quot;読書&quot;] } }
</code></pre>
<p>  「ユーザーの最初の趣味を取り出してください。」</p>
</li>
</ul>
</li>
<li><p><strong>CORS (Cross-Origin Resource Sharing)</strong>:</p>
<ul>
<li>概要: ブラウザのセキュリティ機能。異なるオリジン間のリソース共有を制御。</li>
<li>発生理由: Same-Origin Policy (同一オリジンポリシー)。</li>
<li>ローカル開発での回避策: VSCode Live Serverのプロキシ設定、<code>http-server</code>のCORS有効化オプション (一時的)。本番はサーバー側で適切なCORSヘッダー設定が必要。</li>
</ul>
</li>
<li><p><strong>リクエストのキャンセル</strong>: <code>AbortController</code>と<code>AbortSignal</code>を使用。</p>
<pre><code class="language-javascript">// filepath: (第11章のスクリプト箇所)
const controller = new AbortController();
const signal = controller.signal;
fetch(&#39;url&#39;, { signal })
  .then(res =&gt; {/* ... */})
  .catch(err =&gt; { if (err.name === &#39;AbortError&#39;) console.log(&#39;Fetch aborted&#39;); });
// controller.abort(); // リクエストをキャンセル
</code></pre>
</li>
<li><p><strong>ストリーミング (概要)</strong>: <code>response.body</code> (ReadableStream) を使った大きなデータの段階的処理。</p>
</li>
<li><p><strong>セキュリティ (CSRFとCORS)</strong>: CORSはオリジン間リソース共有、CSRFは別種の脆弱性。Fetch API利用時もサーバー側CSRF対策（トークンなど）が重要。</p>
</li>
<li><p><strong>(参考) <code>XMLHttpRequest</code> (旧), <code>axios</code> (人気ライブラリ)</strong>:</p>
<ul>
<li>Fetch APIとの比較: axiosはJSON自動変換、タイムアウト設定、インターセプターなど多機能。</li>
</ul>
</li>
<li><p><strong>演習</strong>: 公開API (天気情報、国情報など) からデータを取得し、ウェブページに表示。</p>
</li>
</ol>
</li>
</ul>
<hr>
<h3>第4部: モダンJavaScriptとエコシステム – より洗練された開発へ</h3>
<h4>第12章: ES6+の主要機能 – 現代的JavaScriptの記法</h4>
<ul>
<li><strong>目的</strong>: ES2015 (ES6) 以降に導入された主要な構文や機能を理解し、より簡潔で効率的なコードを書けるようにする。</li>
<li><strong>内容</strong>: (これまでの章で触れたものも、ここでまとめて整理・深掘り)<ol>
<li><p><strong><code>let</code> と <code>const</code></strong> (再確認): ブロックスコープ、再代入の可否。</p>
</li>
<li><p><strong>アロー関数</strong> (再確認): 構文、<code>this</code>の挙動、<code>arguments</code>非保持。</p>
</li>
<li><p><strong>テンプレートリテラル</strong>: <code>`Hello, ${name}!`</code></p>
<ul>
<li><p>文字列埋め込み、複数行文字列、式埋め込み。</p>
</li>
<li><p>タグ付きテンプレートリテラル:</p>
<pre><code class="language-javascript">// filepath: (第12章の説明箇所)
function sanitize(strings, ...values) { /* ...エスケープ処理... */ return result; }
const html = sanitize`&lt;div&gt;${untrustedInput}&lt;/div&gt;`;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>デフォルトパラメータ</strong>(再確認): <code>function greet(name = &quot;Guest&quot;) {}</code></p>
</li>
<li><p><strong>レストパラメータ</strong>(再確認): <code>function sum(...numbers) {}</code></p>
</li>
<li><p><strong>スプレッド構文</strong>: <code>...arrayOrObject</code></p>
<ul>
<li>配列展開: <code>const newArr = [...oldArr, newItem];</code></li>
<li>オブジェクト展開 (ES2018): <code>const newObj = { ...oldObj, newProp: val };</code></li>
<li>関数呼び出し時の引数展開: <code>Math.max(...numbersArray);</code></li>
</ul>
</li>
<li><p><strong>デストラクチャリング (分割代入)</strong>:</p>
<ul>
<li>配列: <code>const [first, second] = myArray;</code></li>
<li>オブジェクト: <code>const { name, age } = myObject;</code></li>
<li>デフォルト値: <code>const { country = &quot;Japan&quot; } = myObject;</code></li>
<li>別名: <code>const { name: userName } = myObject;</code></li>
<li>関数の引数での利用: <code>function printUser({ name, age }) {}</code></li>
</ul>
</li>
<li><p><strong>オプショナルチェイニング (<code>?.</code>)</strong> (ES2020): <code>user?.profile?.address?.street</code></p>
<ul>
<li><code>null</code>または<code>undefined</code>の可能性があるプロパティへの安全なアクセス。</li>
</ul>
</li>
<li><p><strong>Null合体演算子 (<code>??</code>)</strong> (ES2020): <code>const value = possiblyNullOrUndefined ?? &quot;defaultValue&quot;;</code></p>
<ul>
<li>左辺が<code>null</code>または<code>undefined</code>の場合に右辺を返す。<code>||</code>との違い (空文字列や0を偽と評価しない)。</li>
</ul>
</li>
<li><p><strong>for...of ループ</strong> (再確認): イテラブルオブジェクトの反復。</p>
</li>
<li><p><strong>シンボル (<code>Symbol</code>)</strong> (再確認): 一意な値、オブジェクトプロパティキー。</p>
</li>
<li><p><strong>イテレータとジェネレータ (概要)</strong>:</p>
<ul>
<li>イテレータブルプロトコル (<code>Symbol.iterator</code>を持つオブジェクト)。</li>
<li>ジェネレータ関数 (<code>function*</code>, <code>yield</code>): イテレータを簡単に作成。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4>第13章: オブジェクト指向プログラミング – クラスとプロトタイプ</h4>
<ul>
<li><strong>目的</strong>: JavaScriptにおけるオブジェクト指向の二つの柱であるプロトタイプベースの継承と、ES6で導入されたクラス構文を理解し、使いこなせるようにする。</li>
<li><strong>内容</strong>:<ol>
<li><strong>プロトタイプとプロトタイプチェーン (再訪と深掘り)</strong>:<ul>
<li><p>全てのオブジェクトはプロトタイプ (<code>[[Prototype]]</code>または<code>__proto__</code>) を持つ。</p>
</li>
<li><p>プロパティ/メソッド探索はプロトタイプチェーンを遡る。</p>
</li>
<li><p><code>Object.getPrototypeOf(obj)</code>: プロトタイプを取得。</p>
</li>
<li><p><code>Object.create(proto, propertiesObject)</code>: 指定したプロトタイプを持つ新しいオブジェクトを作成。</p>
<pre><code class="language-javascript">// filepath: (第13章の説明箇所)
const animal = { makeSound: function() { console.log(&quot;Generic sound&quot;); } };
const dog = Object.create(animal);
dog.breed = &quot;Labrador&quot;;
dog.makeSound(); // &quot;Generic sound&quot; (animalから継承)
</code></pre>
</li>
<li><p>コンストラクタ関数の<code>prototype</code>プロパティ: インスタンスのプロトタイプとなるオブジェクト。</p>
</li>
<li><p>図解必須: インスタンス → コンストラクタの<code>prototype</code> → <code>Object.prototype</code> → <code>null</code>。</p>
</li>
<li><p><code>instanceof</code>演算子: オブジェクトが特定のコンストラクタのインスタンスか判定。</p>
</li>
<li><p>プロトタイプ汚染の危険性 (<code>Object.prototype</code>への安易な追加は避ける)。</p>
</li>
</ul>
</li>
<li><strong>クラス構文 (ES6+)</strong>: モダンなオブジェクト指向の書き方。<ul>
<li><p>クラス宣言: <code>class MyClass { ... }</code></p>
</li>
<li><p>コンストラクタ: <code>constructor(param1) { this.prop1 = param1; }</code></p>
</li>
<li><p>インスタンス化: <code>const instance = new MyClass(value);</code></p>
</li>
<li><p>メソッド定義: <code>myMethod() { ... }</code></p>
</li>
<li><p>ゲッター/セッター: <code>get myProp() { return this._myProp; }</code>, <code>set myProp(value) { /* validation */ this._myProp = value; }</code></p>
<ul>
<li><p>バリデーション演習:</p>
<pre><code class="language-javascript">// filepath: (第13章の説明箇所)
class User { /* ... constructor ... */ set age(value) { if (value &lt; 0) throw new Error(&quot;Age must be positive&quot;); this._age = value; } }
</code></pre>
</li>
</ul>
</li>
<li><p>静的メソッド/プロパティ: <code>static myStaticMethod() { ... }</code>, <code>static myStaticProp = value;</code></p>
<ul>
<li>インスタンスメソッドとの違い: クラス自体に属し、インスタンス化せずに呼び出せる。</li>
</ul>
</li>
<li><p>継承: <code>class SubClass extends SuperClass { constructor(...) { super(...); /* ... */ } }</code></p>
<ul>
<li><code>super()</code>: 親クラスのコンストラクタ呼び出し。<code>this</code>を使う前に必須。</li>
<li><code>super.parentMethod()</code>: 親クラスのメソッド呼び出し。</li>
</ul>
</li>
<li><p>クラスはプロトタイプベースのシンタックスシュガーであることを再確認。</p>
</li>
<li><p><strong>プライベートクラスフィールド/メソッド (<code>#</code>)</strong> (ES2022): <code>#privateField</code>, <code>#privateMethod()</code>。カプセル化。</p>
</li>
<li><p>クラス式: <code>const MyClass = class { ... };</code></p>
</li>
</ul>
</li>
<li><strong>演習</strong>: 簡単なクラス階層（例: <code>Shape</code> -&gt; <code>Circle</code>, <code>Rectangle</code>）を作成し、インスタンス化、メソッド呼び出し、継承を体験。</li>
</ol>
</li>
</ul>
<h4>第14章: 高度なコレクションとデータ操作 – Map, Set, 高階関数</h4>
<ul>
<li><strong>目的</strong>: ES6で導入された新しいコレクション型 (Map, Set) の使い方と、配列操作を強力に行うための高階関数をマスターする。</li>
<li><strong>内容</strong>:<ol>
<li><strong>Map</strong>: キーと値のペアを保持するコレクション。キーは任意の値（オブジェクトも可）。挿入順序を保持。<ul>
<li>作成: <code>new Map()</code>, <code>new Map([[&#39;key1&#39;, &#39;val1&#39;], [&#39;key2&#39;, &#39;val2&#39;]])</code></li>
<li>API: <code>set(key, value)</code>, <code>get(key)</code>, <code>has(key)</code>, <code>delete(key)</code>, <code>clear()</code>, <code>size</code>。</li>
<li>反復処理: <code>keys()</code>, <code>values()</code>, <code>entries()</code>, <code>forEach()</code>。<code>for...of</code>も可能。</li>
<li>オブジェクトとの比較: キーの型、順序、サイズ取得の容易さ。</li>
</ul>
</li>
<li><strong>Set</strong>: 重複しない値のコレクション。<ul>
<li>作成: <code>new Set()</code>, <code>new Set([1, 2, 2, 3])</code> → <code>{1, 2, 3}</code></li>
<li>API: <code>add(value)</code>, <code>has(value)</code>, <code>delete(value)</code>, <code>clear()</code>, <code>size</code>。</li>
<li>反復処理: <code>values()</code>, <code>entries()</code> (キーと値が同じ), <code>forEach()</code>。<code>for...of</code>も可能。</li>
<li>配列との比較: 重複排除、存在確認の効率。</li>
</ul>
</li>
<li><strong>WeakMap / WeakSet</strong>:<ul>
<li>キー (WeakMap) や値 (WeakSet) への参照が弱い。他に参照がなければGC対象。</li>
<li>用途: DOM要素とメタデータの紐付けなど、メモリリークを防ぎたい場合。</li>
</ul>
</li>
<li><strong>配列操作の強力な武器 – 高階関数 (再訪と深掘り)</strong>:<ul>
<li><p>コールバック関数が受け取る引数: <code>callback(currentValue, index, array)</code>。</p>
</li>
<li><p><code>forEach(callback)</code>: 各要素に対して処理を実行 (副作用のため、戻り値なし)。</p>
</li>
<li><p><code>map(callback)</code>: 各要素を変換し、新しい配列を生成 (非破壊的)。</p>
</li>
<li><p><code>filter(callback)</code>: 条件に合う要素のみを抽出し、新しい配列を生成 (非破壊的)。</p>
</li>
<li><p><code>reduce(callback, initialValue)</code>: 配列を単一の値に畳み込む。</p>
<ul>
<li><p>具体例: 合計計算、オブジェクトへの変換。</p>
<pre><code class="language-javascript">// filepath: (第14章の説明箇所)
const people = [{id:&#39;a&#39;, name:&#39;A&#39;}, {id:&#39;b&#39;, name:&#39;B&#39;}];
const peopleById = people.reduce((acc, p) =&gt; { acc[p.id] = p; return acc; }, {});
</code></pre>
</li>
</ul>
</li>
<li><p><code>find(callback)</code>: 条件に合う最初の要素を返す。</p>
</li>
<li><p><code>findIndex(callback)</code>: 条件に合う最初の要素のインデックスを返す。</p>
</li>
<li><p><code>some(callback)</code>: 条件に合う要素が一つでもあれば<code>true</code>。</p>
</li>
<li><p><code>every(callback)</code>: 全ての要素が条件に合えば<code>true</code>。</p>
</li>
<li><p><code>flatMap(callback)</code> (ES2019): <code>map</code>してから結果をフラット化。</p>
</li>
<li><p><code>sort(compareFunction)</code>: 配列をソート (破壊的)。比較関数の重要性。</p>
</li>
<li><p>メソッドチェーン: <code>array.filter(...).map(...).reduce(...)</code>。</p>
</li>
</ul>
</li>
<li><strong>演習</strong>: Map/Setを使ったデータ管理、高階関数を使った複雑なデータ変換。</li>
</ol>
</li>
</ul>
<h4>第15章: モジュールシステム – コードの分割と再利用</h4>
<ul>
<li><strong>目的</strong>: JavaScriptコードをファイル単位で分割し、再利用性や保守性を高めるためのモジュールシステム (ES Modules) を理解し、使えるようにする。</li>
<li><strong>内容</strong>:<ol>
<li><strong>なぜモジュールが必要か</strong>:<ul>
<li>グローバルスコープの汚染防止。</li>
<li>コードの再利用性向上。</li>
<li>保守性の向上 (関心事の分離)。</li>
<li>依存関係の明確化。</li>
</ul>
</li>
<li><strong>ES Modules (ESM)</strong>: ブラウザとNode.jsで標準化されたモジュールシステム。<ul>
<li>エクスポート (<code>export</code>):<ul>
<li>名前付きエクスポート: <code>export const myVar = ...;</code>, <code>export function myFunc() {}</code></li>
<li>デフォルトエクスポート: <code>export default function() {}</code> (ファイルごとに一つのみ)。</li>
</ul>
</li>
<li>インポート (<code>import</code>):<ul>
<li>名前付きインポート: <code>import { myVar, myFunc } from &#39;./myModule.js&#39;;</code></li>
<li>デフォルトインポート: <code>import myDefaultFunc from &#39;./myModule.js&#39;;</code></li>
<li>全てインポート (名前空間): <code>import * as myModule from &#39;./myModule.js&#39;;</code> (<code>myModule.myVar</code>)</li>
<li>別名インポート: <code>import { myFunc as anotherName } from &#39;./myModule.js&#39;;</code></li>
</ul>
</li>
<li>HTMLでの利用: <code>&lt;script type=&quot;module&quot; src=&quot;main.js&quot;&gt;&lt;/script&gt;</code>。</li>
<li>ファイルパス: 相対パス (<code>./</code>, <code>../</code>) または絶対パス。</li>
</ul>
</li>
<li><strong>CommonJS (CJS)</strong>: 主にNode.jsで使われてきたモジュールシステム。<ul>
<li>エクスポート: <code>module.exports = ...;</code>, <code>exports.prop = ...;</code></li>
<li>インポート: <code>const myModule = require(&#39;./myModule.js&#39;);</code></li>
<li>ESMとの主な違い:<ul>
<li>構文: <code>import/export</code> vs <code>require/module.exports</code>。</li>
<li>ロードタイミング: ESMは静的 (解析時)、CJSは動的 (実行時)。</li>
<li><code>this</code>の挙動: ESMのトップレベル<code>this</code>は<code>undefined</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>バンドラーの役割</strong>:<ul>
<li>複数のモジュールファイルを一つにまとめる (HTTPリクエスト削減)。</li>
<li>依存関係の解決。</li>
<li>古いブラウザのためのトランスパイル (Babel連携)。</li>
<li>Tree Shaking (未使用コードの削除) などの最適化。</li>
<li>代表例: Webpack, Rollup, Parcel, Vite (Viteを紹介)。</li>
</ul>
</li>
<li><strong>動的インポート (<code>import()</code>)</strong>:<ul>
<li>Promiseを返す関数。条件に応じてモジュールを遅延ロード。</li>
<li><code>const module = await import(&#39;./myModule.js&#39;);</code></li>
<li>コード分割 (Code Splitting) による初期ロード時間短縮。</li>
</ul>
</li>
<li><strong>循環参照の問題</strong>: モジュールAがBを、BがAをインポートする状況。<ul>
<li>発生しうる問題と回避策 (設計見直し、一部動的インポートなど)。</li>
</ul>
</li>
<li><strong>演習</strong>: 複数のJSファイルで関数/変数をエクスポート/インポートして連携させる。</li>
</ol>
</li>
</ul>
<h4>第16章: 開発ツールとテスト入門 – 品質と効率を高める</h4>
<ul>
<li><strong>目的</strong>: 現代のJavaScript開発を支える主要なツール（リンター、フォーマッタ、パッケージマネージャ、トランスパイラ）の役割を理解し、テストの基本的な考え方と簡単なユニットテストを体験する。</li>
<li><strong>内容</strong>:<ol>
<li><strong>jQuery (歴史的意義)</strong>: かつてのブラウザ差異吸収、DOM操作簡略化、Ajax。現代では標準API充実とフレームワーク台頭で新規採用は減少。</li>
<li><strong>リンター (Linter)</strong>: コードの静的解析ツール。<ul>
<li>ESLint: 文法エラー、潜在的なバグ、コーディングスタイル違反を検知。</li>
<li>導入メリット: コード品質向上、バグ早期発見、チームでのスタイル統一。</li>
<li>VSCode拡張機能との連携。</li>
</ul>
</li>
<li><strong>フォーマッタ (Formatter)</strong>: コードの見た目を自動整形。<ul>
<li>Prettier: 対応言語多数。設定ファイルでカスタマイズ可能。</li>
<li>導入メリット: 可読性向上、コードレビューの効率化 (スタイルに関する議論削減)。</li>
<li>保存時自動整形の設定。</li>
</ul>
</li>
<li><strong>パッケージマネージャ</strong>: ライブラリやツールの管理。<ul>
<li>npm (Node Package Manager): Node.jsに付属。</li>
<li><code>package.json</code>: プロジェクト情報、依存関係、スクリプトを記述。<ul>
<li>主要項目: <code>name</code>, <code>version</code>, <code>description</code>, <code>main</code>, <code>scripts</code>, <code>dependencies</code>, <code>devDependencies</code>。</li>
</ul>
</li>
<li><code>npm install &lt;package&gt;</code>: パッケージインストール。</li>
<li><code>npm run &lt;script-name&gt;</code>: <code>scripts</code>に定義したコマンド実行。</li>
<li><code>package-lock.json</code> / <code>yarn.lock</code>: 依存関係のバージョンを固定し、環境再現性を担保。</li>
<li>Yarn: npm互換のパッケージマネージャ (速度や機能面での改善を目指したもの)。</li>
</ul>
</li>
<li><strong>トランスパイラ (Transpiler)</strong>: 新しい構文のコードを古い環境でも動くコードに変換。<ul>
<li>Babel: ES6+のJavaScriptをES5などに変換。JSX変換も。</li>
<li>役割の具体例: アロー関数やクラス構文がES5互換コードに変換される様子。</li>
</ul>
</li>
<li><strong>テストの重要性と種類</strong>:<ul>
<li>なぜテストが必要か: バグの早期発見、リファクタリングの安心感、ドキュメントとしての役割。</li>
<li>ユニットテスト: 関数やモジュールなど最小単位のテスト。</li>
<li>結合テスト: 複数のモジュールを組み合わせたテスト。</li>
<li>E2E (End-to-End) テスト: ユーザー操作をシミュレートし、アプリケーション全体をテスト。</li>
</ul>
</li>
<li><strong>ユニットテスト入門 (Jest / Vitest)</strong>:<ul>
<li><p>Jest: 多機能なテストフレームワーク。設定少なめ。</p>
</li>
<li><p>Vitest: Viteベースの高速なテストフレームワーク。ESMネイティブサポート。</p>
</li>
<li><p>簡単なアサーション: <code>expect(value).toBe(expectedValue);</code></p>
<pre><code class="language-javascript">// filepath: sum.js
// export function sum(a, b) { return a + b; } // ESM
function sum(a,b) { return a + b; } module.exports = sum; // CJS for basic Jest

// filepath: sum.test.js
// import { sum } from &#39;./sum&#39;; // ESM
const sum = require(&#39;./sum&#39;); // CJS
describe(&#39;sum function&#39;, () =&gt; {
  it(&#39;should add two positive numbers&#39;, () =&gt; {
    expect(sum(1, 2)).toBe(3);
  });
});
</code></pre>
</li>
<li><p><code>npm test</code> (または <code>npx jest</code>, <code>npx vitest</code>) で実行。</p>
</li>
</ul>
</li>
<li><strong>TDD (テスト駆動開発) の考え方</strong>: Red (テスト失敗) → Green (テスト成功) → Refactor (リファクタリング) のサイクル。</li>
</ol>
</li>
</ul>
<hr>
<h3>第5部: さらなるステップアップ – 専門分野への扉</h3>
<h4>第17章: フロントエンドフレームワーク/ライブラリ概論</h4>
<ul>
<li><strong>目的</strong>: 主要なフロントエンドフレームワーク/ライブラリ (React, Vue, Angular) の特徴、基本的な考え方、エコシステムを理解し、自身のプロジェクトや学習目標に合ったものを選択するための知識を得る。</li>
<li><strong>内容</strong>:<ol>
<li><strong>なぜフレームワーク/ライブラリが必要か</strong>:<ul>
<li>複雑なUIの効率的な構築と管理。</li>
<li>コンポーネントベース開発による再利用性と保守性の向上。</li>
<li>状態管理の仕組み。</li>
<li>ルーティング、データバインディングなどの共通機能提供。</li>
</ul>
</li>
<li><strong>React</strong>: Facebook製のUIライブラリ。<ul>
<li>特徴: コンポーネントベース、JSX (JavaScript XML)、仮想DOM、宣言的UI。</li>
<li>エコシステム: Create React App, Next.js (SSR/SSG), Zustand/Redux (状態管理), React Router (ルーティング)。</li>
<li>学習リソース: 公式チュートリアル, Egghead.io, Scrimba。</li>
<li>長所: 柔軟性高い、巨大なコミュニティとエコシステム、求人数多い。</li>
<li>短所: UIライブラリであり、ルーティング等は別途選択が必要。JSXに慣れが必要。</li>
</ul>
</li>
<li><strong>Vue.js</strong>: プログレッシブフレームワーク。<ul>
<li>特徴: SFC (.vueファイル)、テンプレート構文、Options API/Composition API、リアクティブデータバインディング。</li>
<li>エコシステム: Vue CLI, Nuxt.js (SSR/SSG), Pinia/Vuex (状態管理), Vue Router (ルーティング)。</li>
<li>学習リソース: 公式ガイド, Vue Mastery, Laracasts (Vue)。</li>
<li>長所: 学習コスト比較的低い、公式ドキュメント充実、柔軟性とパフォーマンスのバランスが良い。</li>
<li>短所: Reactに比べるとエコシステムの規模は小さい (が十分大きい)。</li>
</ul>
</li>
<li><strong>Angular</strong>: Google製のフルスタックフレームワーク。<ul>
<li>特徴: TypeScriptベース、モジュール/コンポーネント/サービス/DI (依存性注入)、RxJS多用、CLI強力。</li>
<li>エコシステム: Angular CLI, NgRx (状態管理), Angular Universal (SSR)。</li>
<li>学習リソース: 公式ドキュメント「Tour of Heroes」, Ultimate Angular。</li>
<li>長所: 大規模開発向け、フル装備、厳格な構造。</li>
<li>短所: 学習コスト高い、RxJSの理解が鍵、ファイル数多くなりがち。</li>
</ul>
</li>
<li><strong>Svelte / SolidJS (次世代の選択肢として軽く触れる)</strong>:<ul>
<li>Svelte: コンパイラ。仮想DOMなしで効率的な命令型コードを生成。</li>
<li>SolidJS: JSX、リアクティブプリミティブ。仮想DOMなしで高速。</li>
</ul>
</li>
<li><strong>選択指針</strong>:<ul>
<li>プロジェクト規模、チームのスキルセット、学習意欲、エコシステムの成熟度などを考慮。</li>
<li>「小規模で学習コストを抑えたいならVue。エコシステムや求人数を重視するならReact。フルスタックな機能と厳格な型付けを求めるならAngular。まずは公式のGetting Startedを試して、自分に合うものを見つけましょう。」</li>
</ul>
</li>
<li><strong>共通の概念</strong>: コンポーネント、状態 (State)、プロパティ (Props)、ライフサイクル、ルーティング。</li>
</ol>
</li>
</ul>
<h4>第18章: Node.jsによるサーバーサイド開発入門</h4>
<ul>
<li><strong>目的</strong>: Node.jsを使って簡単なサーバーを構築し、APIエンドポイントを作成する基本的な方法を学ぶ。Express.jsフレームワークの導入。</li>
<li><strong>内容</strong>:<ol>
<li><strong>Node.jsとは (再確認)</strong>: Chrome V8エンジンで動作するサーバーサイドJavaScript実行環境。</li>
<li><strong>Node.jsのコアモジュール</strong>:<ul>
<li><code>http</code>: HTTPサーバー/クライアント機能。</li>
<li><code>fs</code>: ファイルシステム操作。</li>
<li><code>path</code>: ファイルパス操作。</li>
<li><code>events</code>: イベント駆動プログラミングの基盤。</li>
</ul>
</li>
<li><strong>簡単なHTTPサーバーの作成</strong>: <code>http.createServer()</code> を使った基本的な例。</li>
<li><strong>Express.js</strong>: Node.jsのための最小限で柔軟なWebアプリケーションフレームワーク。<ul>
<li>インストール: <code>npm install express</code></li>
<li>基本的なルーティング: <code>app.get(&#39;/&#39;, (req, res) =&gt; { ... });</code>, <code>app.post(&#39;/api/data&#39;, (req, res) =&gt; { ... });</code></li>
<li>ミドルウェア: リクエスト/レスポンスオブジェクトへのアクセス、処理の連鎖。<ul>
<li><code>express.json()</code>: JSONリクエストボディのパース。</li>
<li><code>express.static()</code>: 静的ファイルの配信。</li>
</ul>
</li>
<li>リクエストオブジェクト (<code>req</code>): <code>req.params</code>, <code>req.query</code>, <code>req.body</code>。</li>
<li>レスポンスオブジェクト (<code>res</code>): <code>res.send()</code>, <code>res.json()</code>, <code>res.status()</code>。</li>
</ul>
</li>
<li><strong>REST APIの設計原則 (概要)</strong>: リソースベース、HTTPメソッドの適切な使用、ステータスコード。</li>
<li><strong>データベースとの連携 (概要)</strong>:<ul>
<li>ORM (Object-Relational Mapper): Prisma, Sequelizeなど。</li>
<li>NoSQLデータベース: MongoDBなど。</li>
</ul>
</li>
<li><strong>演習</strong>: Express.jsを使って簡単なCRUD APIを作成する。</li>
<li><strong>学習リソース</strong>: Node.js公式ドキュメント, Express.js公式ガイド, The Net Ninja (Node.jsコース)。</li>
</ol>
</li>
</ul>
<h4>第19章: TypeScript入門 – 静的型付けの世界へ</h4>
<ul>
<li><strong>目的</strong>: JavaScriptに静的型システムを追加するTypeScriptの基本的な概念、利点、使い方を理解し、簡単なTypeScriptコードを書けるようにする。</li>
<li><strong>内容</strong>:<ol>
<li><strong>TypeScriptとは</strong>: Microsoft製のオープンソース言語。JavaScriptのスーパーセット。</li>
<li><strong>なぜTypeScriptか？ 静的型付けの恩恵</strong>:<ul>
<li>コンパイル時のエラー検知 (タイプミス、不正な型操作など)。</li>
<li>コードの可読性・保守性向上。</li>
<li>エディタの強力な補完機能 (IntelliSense)。</li>
<li>リファクタリングの安全性向上。</li>
<li>大規模開発での恩恵大。</li>
</ul>
</li>
<li><strong>基本的な型</strong>:<ul>
<li>プリミティブ型: <code>string</code>, <code>number</code>, <code>boolean</code>, <code>null</code>, <code>undefined</code>, <code>symbol</code>, <code>bigint</code>。</li>
<li>配列: <code>number[]</code> または <code>Array&lt;number&gt;</code>。</li>
<li>オブジェクト: <code>{ name: string, age: number }</code>。</li>
<li><code>any</code>: 型チェックを無効化 (非推奨、最終手段)。</li>
<li><code>unknown</code>: <code>any</code>より安全な型。使用前に型チェックや型アサーションが必要。</li>
<li><code>void</code>: 関数が何も返さないことを示す。</li>
<li><code>never</code>: 関数が決して戻らない (常にエラーを投げる、無限ループなど)。</li>
</ul>
</li>
<li><strong>インターフェース (<code>interface</code>) と型エイリアス (<code>type</code>)</strong>: オブジェクトの形状を定義。<ul>
<li><code>interface User { name: string; age: number; }</code></li>
<li><code>type Point = { x: number; y: number; };</code></li>
<li>使い分け: <code>interface</code>は拡張可能 (宣言のマージ、<code>implements</code>)、<code>type</code>はより柔軟 (ユニオン型、交差型など)。</li>
</ul>
</li>
<li><strong>関数と型</strong>:<ul>
<li>引数の型注釈、戻り値の型注釈。</li>
<li><code>function add(a: number, b: number): number { return a + b; }</code></li>
</ul>
</li>
<li><strong>ジェネリクス (<code>&lt;T&gt;</code>)</strong>: 型をパラメータ化し、再利用可能なコンポーネントを作成。<ul>
<li><code>function identity&lt;T&gt;(arg: T): T { return arg; }</code></li>
</ul>
</li>
<li><strong>型推論</strong>: TypeScriptが文脈から型を推測する機能。</li>
<li><strong>型アサーション</strong>: <code>value as string</code> または <code>&lt;string&gt;value</code> (JSXと競合注意)。開発者が型を上書き。</li>
<li><strong>ユニオン型 (<code>|</code>) と交差型 (<code>&amp;</code>)</strong>:<ul>
<li>ユニオン型: <code>string | number</code> (文字列または数値)。</li>
<li>交差型: <code>TypeA &amp; TypeB</code> (TypeAとTypeBの両方の特性を持つ)。</li>
</ul>
</li>
<li><strong>設定ファイル (<code>tsconfig.json</code>)</strong>: コンパイラオプションの設定。</li>
<li><strong>コンパイル</strong>: <code>tsc</code>コマンドでTypeScriptコードをJavaScriptコードに変換。</li>
<li><strong>学習コスト/コンパイル</strong>: 型システムの学習、<code>tsconfig.json</code>の設定、ビルドツールとの連携。</li>
<li><strong>演習</strong>: JavaScriptで書かれた簡単な関数やオブジェクトに型注釈を付けてみる。</li>
</ol>
</li>
</ul>
<h4>第20章: Webアクセシビリティ (a11y) の基本</h4>
<ul>
<li><strong>目的</strong>: 全てのユーザーがウェブコンテンツにアクセスし利用できるようにするためのWebアクセシビリティの重要性と基本的な実践方法を学ぶ。</li>
<li><strong>内容</strong>:<ol>
<li><strong>Webアクセシビリティ (a11y) とは</strong>: 高齢者や障害を持つ人々を含む、誰もが情報にアクセスし利用できること。</li>
<li><strong>なぜ重要か</strong>:<ul>
<li>倫理的責任、法的要件 (国による)。</li>
<li>ビジネスメリット (ユーザー層拡大、SEO向上)。</li>
<li>ユーザビリティ向上 (全てのユーザーにとって使いやすくなる)。</li>
</ul>
</li>
<li><strong>WCAG (Web Content Accessibility Guidelines)</strong>: アクセシビリティの国際標準。4つの原則 (知覚可能、操作可能、理解可能、堅牢)。</li>
<li><strong>具体的な実践方法</strong>:<ul>
<li><strong>セマンティックHTML</strong>: 適切なHTMLタグ (<code>&lt;nav&gt;</code>, <code>&lt;main&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;aside&gt;</code>, <code>&lt;button&gt;</code>, <code>&lt;h1&gt;</code>-<code>&lt;h6&gt;</code>など) を使用する。<code>&lt;div&gt;</code>や<code>&lt;span&gt;</code>の乱用を避ける。</li>
<li><strong>キーボード操作</strong>: 全てのインタラクティブ要素がキーボードのみで操作可能であること (Tabキーでのフォーカス移動、Enter/Spaceでの実行)。フォーカスインジケータの表示。</li>
<li><strong>画像と代替テキスト</strong>: <code>&lt;img&gt;</code>タグには適切な<code>alt</code>属性を設定する。装飾画像なら<code>alt=&quot;&quot;</code>。</li>
<li><strong>フォームのアクセシビリティ</strong>: <code>&lt;label&gt;</code>と入力要素 (<code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code>, <code>&lt;select&gt;</code>) を関連付ける (<code>for</code>属性と<code>id</code>属性)。エラーメッセージの適切な表示。</li>
<li><strong>色のコントラスト</strong>: テキストと背景のコントラスト比を十分に確保する (WCAG基準)。コントラストチェッカーツール活用。</li>
<li><strong>ARIA (Accessible Rich Internet Applications)</strong>: HTMLだけでは表現しきれない動的なUIコンポーネント (タブ、モーダル、スライダーなど) の役割、状態、プロパティをスクリーンリーダーなどの支援技術に伝える。<ul>
<li><code>role</code>属性、<code>aria-*</code>属性 (例: <code>aria-label</code>, <code>aria-hidden</code>, <code>aria-expanded</code>)。</li>
</ul>
</li>
<li><strong>動画・音声コンテンツ</strong>: 字幕、トランスクリプトの提供。</li>
</ul>
</li>
<li><strong>テストとツール</strong>:<ul>
<li>手動テスト: キーボード操作確認、スクリーンリーダー (NVDA, VoiceOver, JAWS) での読み上げ確認。</li>
<li>自動テストツール: Lighthouse (Chrome DevTools), axe DevTools (ブラウザ拡張機能)。</li>
</ul>
</li>
<li><strong>開発プロセスへの組み込み</strong>: 設計段階からアクセシビリティを考慮する。</li>
</ol>
</li>
</ul>
<h4>第21章: 本格的なテスト戦略 – 品質を支える多様なテスト</h4>
<ul>
<li><strong>目的</strong>: アプリケーションの品質を保証するための様々なテスト手法（ユニットテストの深掘り、コンポーネントテスト、E2Eテスト）の概要と、それらを組み合わせたテスト戦略の考え方を学ぶ。</li>
<li><strong>内容</strong>:<ol>
<li><strong>テストピラミッド</strong>: ユニットテスト (多)、結合テスト (中)、E2Eテスト (少) のバランス。</li>
<li><strong>ユニットテスト (深掘り)</strong>:<ul>
<li>テストランナー/フレームワーク: Jest, Vitest, Mocha, Jasmine。</li>
<li>アサーションライブラリ: <code>expect</code> (Jest/Vitest組み込み), Chai。</li>
<li>モック、スタブ、スパイ: 依存関係を分離し、テスト対象を隔離する。<ul>
<li><code>jest.fn()</code>: モック関数。呼び出し回数や引数の記録。</li>
<li><code>jest.spyOn(object, &#39;methodName&#39;)</code>: 既存関数の呼び出しを監視。</li>
<li><code>jest.mock(&#39;./module&#39;)</code>: モジュール全体をモック。</li>
</ul>
</li>
<li>カバレッジレポート: テストがコードのどの程度をカバーしているか。</li>
<li>スナップショットテスト: UIコンポーネントやデータ構造の出力を記録し、変更を検知。</li>
</ul>
</li>
<li><strong>コンポーネントテスト</strong>: UIコンポーネントを単体でテスト。<ul>
<li>React: React Testing Library, Enzyme (旧)。</li>
<li>Vue: Vue Test Utils。</li>
<li>Svelte: Svelte Testing Library。</li>
<li>ユーザーの視点でのテスト (表示内容、インタラクション)。</li>
</ul>
</li>
<li><strong>E2E (End-to-End) テスト</strong>: アプリケーション全体をユーザーのように操作してテスト。<ul>
<li>フレームワーク: Cypress, Playwright, Selenium。</li>
<li>シナリオベース: ユーザー登録、商品購入などの一連の流れをテスト。</li>
<li>実行時間長く、不安定になりやすいが、最も信頼性の高いテスト。</li>
</ul>
</li>
<li><strong>結合テスト</strong>: 複数のユニット/モジュールが連携して正しく動作するかテスト。</li>
<li><strong>テスト戦略の考え方</strong>:<ul>
<li>リスクベース: 重要な機能、変更頻度の高い箇所を重点的に。</li>
<li>CI/CDパイプラインへの統合: 自動テストの実行。</li>
<li>テストしやすいコード設計 (疎結合、純粋関数など)。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4>第22章: 状態管理ライブラリの考え方 – アプリケーションデータを効率的に扱う</h4>
<ul>
<li><strong>目的</strong>: 中規模以上のフロントエンドアプリケーションで複雑化する状態（データ）を一元的に管理するための状態管理ライブラリ（Redux, Pinia/Vuex, Zustandなど）の基本的な考え方と必要性を理解する。</li>
<li><strong>内容</strong>:<ol>
<li><strong>なぜ状態管理が必要か</strong>:<ul>
<li>コンポーネント間のデータ受け渡し (Props Drilling問題)。</li>
<li>アプリケーション全体のグローバルな状態の一元管理。</li>
<li>状態変更の予測可能性と追跡の容易化。</li>
<li>非同期処理との連携。</li>
</ul>
</li>
<li><strong>基本的な状態管理パターン</strong>:<ul>
<li>ローカルコンポーネント状態: <code>useState</code> (React), <code>data</code>オプション (Vue)。</li>
<li>Context API (React) / Provide/Inject (Vue): Props Drillingを避けるための組み込み機能。</li>
</ul>
</li>
<li><strong>Fluxアーキテクチャ (Reduxの基礎)</strong>:<ul>
<li>一方向のデータフロー: Action → Dispatcher → Store → View。</li>
</ul>
</li>
<li><strong>Redux (React向け、他でも利用可)</strong>:<ul>
<li>Store: アプリケーションの状態を保持する唯一の場所。</li>
<li>Action: 状態変更の意図を表すプレーンオブジェクト (<code>{ type: &#39;ACTION_TYPE&#39;, payload: ... }</code>)。</li>
<li>Reducer: 現在の状態とActionを受け取り、新しい状態を返す純粋関数。</li>
<li>Dispatch: ActionをStoreに送る関数。</li>
<li>Middleware: 非同期処理 (Redux Thunk, Redux Saga)、ロギングなど。</li>
<li>React Redux: <code>useSelector</code>, <code>useDispatch</code>フック。</li>
</ul>
</li>
<li><strong>Pinia (Vue 3向け推奨) / Vuex (Vue 2/3)</strong>:<ul>
<li>Store (Pinia) / State (Vuex): 状態。</li>
<li>Getters: 状態から派生した値を計算。</li>
<li>Mutations (Vuex) / Actions (Piniaの同期処理): 状態を同期的に変更。</li>
<li>Actions: 非同期処理を行い、Mutationをコミット (Vuex) / 状態を直接変更 (Pinia)。</li>
</ul>
</li>
<li><strong>Zustand (React向け)</strong>: シンプルで軽量な状態管理ライブラリ。フックベース。</li>
<li><strong>選択基準</strong>:<ul>
<li>アプリケーションの規模と複雑性。</li>
<li>チームの習熟度。</li>
<li>エコシステムとの親和性。</li>
<li>学習コストとボイラープレートの量。</li>
</ul>
</li>
<li><strong>状態管理のベストプラクティス</strong>:<ul>
<li>状態の正規化。</li>
<li>イミュータブルな状態更新。</li>
<li>DevToolsの活用。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4>第23章: WebAssembly, サーバーレス, DevOps – 次世代技術への展望</h4>
<ul>
<li><strong>目的</strong>: JavaScriptエコシステムのさらに進んだトピックや、関連する次世代技術の概要を理解し、将来的な学習の方向性を探る。</li>
<li><strong>内容</strong>:<ol>
<li><strong>WebAssembly (Wasm)</strong>:<ul>
<li>概要: ブラウザ (およびNode.js) で実行可能なバイナリ形式のコード。</li>
<li>目的: C++/Rust/Goなどで書かれたコードをウェブで高速に実行。</li>
<li>JavaScriptとの連携: JavaScriptからWasmモジュールを呼び出し、WasmからJavaScript関数を呼び出す。</li>
<li>ユースケース: ゲーム、画像/動画処理、計算量の多い処理、既存ネイティブコードのウェブ移植。</li>
</ul>
</li>
<li><strong>サーバーレスアーキテクチャ</strong>:<ul>
<li>概要: サーバーの管理・運用をクラウドプロバイダーに任せ、関数単位でコードを実行するモデル。</li>
<li>FaaS (Function as a Service): AWS Lambda, Google Cloud Functions, Azure Functions, Vercel Functions, Netlify Functions。</li>
<li>メリット: スケーラビリティ、コスト効率 (実行時間課金)、運用負荷軽減。</li>
<li>デメリット: ベンダーロックイン、コールドスタート、ローカルテストの難しさ。</li>
<li>ユースケース: APIバックエンド、データ処理、イベント駆動処理。</li>
</ul>
</li>
<li><strong>Jamstack</strong>: JavaScript, API, Markup。静的サイトジェネレータ (SSG) とヘッドレスCMSを活用したモダンなウェブサイト構築アプローチ。</li>
<li><strong>GraphQL</strong>: APIのためのクエリ言語とサーバーサイドランタイム。<ul>
<li>RESTとの違い: クライアントが必要なデータだけをリクエスト可能 (オーバーフェッチ/アンダーフェッチ解消)。単一エンドポイント。型システム。</li>
</ul>
</li>
<li><strong>DevOpsとCI/CD</strong>:<ul>
<li>DevOps: 開発 (Development) と運用 (Operations) の連携・協調。</li>
<li>CI (Continuous Integration): コード変更を頻繁にマージし、自動ビルド・テストを実行。</li>
<li>CD (Continuous Delivery/Deployment): CIパイプラインを通過したコードを自動的に本番環境へリリース。</li>
<li>ツール: GitHub Actions, GitLab CI, Jenkins。</li>
</ul>
</li>
<li><strong>PWA (Progressive Web Apps)</strong>: ウェブアプリにネイティブアプリのような体験を提供。オフライン対応、プッシュ通知、ホーム画面追加など。</li>
<li><strong>WebRTC</strong>: ブラウザ間でリアルタイム通信 (音声、動画、データ)。</li>
</ol>
</li>
</ul>
<h4>第24章: 学習を継続するために – コミュニティと情報収集、そして専門家への道</h4>
<ul>
<li><strong>目的</strong>: これまでの学習を土台に、JavaScript専門家として成長し続けるための情報収集方法、コミュニティ参加、キャリアパスについて考える。</li>
<li><strong>内容</strong>:<ol>
<li><strong>学び続けることの重要性</strong>: JavaScriptエコシステムは変化が速い。</li>
<li><strong>情報収集の方法</strong>:<ul>
<li>公式ドキュメント: MDN, 各フレームワーク/ライブラリの公式サイト。</li>
<li>技術ブログ/ニュースサイト: dev.to, Smashing Magazine, CSS-Tricks, Hacker News, Zenn, Qiita。</li>
<li>ニュースレター: JavaScript Weekly, Frontend Focus, Node Weekly。</li>
<li>カンファレンス/ミートアップ動画: YouTube (JSConf, Google I/O, etc.)。</li>
<li>書籍: 定番書、専門書。</li>
<li>Twitter/SNS: 著名な開発者や技術アカウントをフォロー。</li>
</ul>
</li>
<li><strong>コミュニティへの参加</strong>:<ul>
<li>オンラインフォーラム: Stack Overflow, Reddit (r/javascriptなど), Discord/Slackコミュニティ。</li>
<li>オフライン/オンライン勉強会、ミートアップ。</li>
<li>OSSコントリビューション: GitHubで興味のあるプロジェクトに参加。</li>
</ul>
</li>
<li><strong>アウトプットの重要性</strong>:<ul>
<li>技術ブログを書く。</li>
<li>GitHubで個人プロジェクトを公開する。</li>
<li>勉強会で発表する。</li>
<li>学んだことを同僚や友人に教える。</li>
</ul>
</li>
<li><strong>キャリアパスの例</strong>:<ul>
<li>フロントエンドエンジニア (React/Vue/Angularなど)。</li>
<li>バックエンドエンジニア (Node.js)。</li>
<li>フルスタックエンジニア。</li>
<li>モバイルアプリ開発 (React Native, NativeScriptなど)。</li>
<li>デスクトップアプリ開発 (Electron)。</li>
<li>DevOpsエンジニア、SRE。</li>
<li>テクニカルライター、エバンジェリスト。</li>
</ul>
</li>
<li><strong>ソフトスキルの重要性</strong>:<ul>
<li>コミュニケーション能力。</li>
<li>問題解決能力。</li>
<li>チームワーク。</li>
<li>ドキュメンテーション能力。</li>
<li>学習意欲と適応力。</li>
</ul>
</li>
<li><strong>最後に</strong>: 継続的な学習と実践を通じて、JavaScriptの世界を楽しみ、専門性を高めていきましょう。</li>
</ol>
</li>
</ul>
<hr>
<p><strong>自己評価と残る懸念 (再掲):</strong></p>
<ul>
<li><strong>学習の連続性</strong>: 各資料間の繋がりや、前の資料で学んだことが次の資料でどう活かされるかを意識した構成にする必要があります。</li>
<li><strong>実践課題</strong>: 各章の終わりに確認問題やコード記述演習を設けることで、理解度確認と実践力向上を図ります。</li>
<li><strong>図解の活用</strong>: スコープ、イベントループ、プロトタイプチェーンなど、視覚的な理解が助けとなる箇所では、図解を積極的に活用することを推奨します。</li>
</ul>
<p>この構成案を元に、各資料の具体的な内容を肉付けしていくことになります。</p>

      </body>
      </html>
    