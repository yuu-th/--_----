name: Convert Markdown to HTML and PDF

on:
  push:
    branches: [ main, master ]

# ワークフローに明示的な権限を設定
permissions:
  contents: write

jobs:
  convert-documents:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: |
          npm init -y
          npm install --save marked puppeteer@19.7.0

      - name: Install Japanese fonts
        run: |
          sudo apt-get update
          sudo apt-get install -y fonts-ipafont-gothic fonts-ipafont-mincho fonts-noto-cjk

      - name: Create conversion script
        run: |
          cat > convert.js << 'EOL'
          const fs = require('fs');
          const path = require('path');
          const marked = require('marked');
          const puppeteer = require('puppeteer');

          // Check if root style.css exists
          const rootStyleExists = fs.existsSync('./style.css');
          const rootStyleContent = rootStyleExists ? fs.readFileSync('./style.css', 'utf-8') : '';

          // Function to copy a file
          function copyFile(source, target) {
            try {
              // Create directory if it doesn't exist
              const targetDir = path.dirname(target);
              if (!fs.existsSync(targetDir)) {
                fs.mkdirSync(targetDir, { recursive: true });
              }
              fs.copyFileSync(source, target);
              return true;
            } catch (error) {
              console.error(`Error copying file ${source} to ${target}:`, error);
              return false;
            }
          }

          // Function to copy all assets (images, etc.)
          function copyAssets(sourceDir, targetDir, excludeDirs = ['node_modules', '.git', 'output']) {
            const imageExtensions = ['.png', '.jpg', '.jpeg', '.gif', '.svg', '.webp', '.bmp', '.ico'];
            
            function copyAssetsRecursive(dir, targetBase) {
              const entries = fs.readdirSync(dir, { withFileTypes: true });
              
              for (const entry of entries) {
                if (excludeDirs.includes(entry.name)) continue;
                
                const sourcePath = path.join(dir, entry.name);
                const targetPath = path.join(targetBase, entry.name);
                
                if (entry.isDirectory()) {
                  copyAssetsRecursive(sourcePath, targetPath);
                } else if (entry.isFile()) {
                  const ext = path.extname(entry.name).toLowerCase();
                  if (imageExtensions.includes(ext)) {
                    copyFile(sourcePath, targetPath);
                  }
                }
              }
            }
            
            copyAssetsRecursive(sourceDir, targetDir);
          }

          // Function to fix image paths in HTML content for PDF generation
          function fixImagePathsForPdf(htmlContent, basePath) {
            // Convert relative image paths to absolute paths
            return htmlContent.replace(
              /(src|href)="(?!http|\/\/|data:)(.*?)"/g,
              (match, attr, url) => {
                // Adjust the URL to point to the copied image in the output directory
                if (path.extname(url).match(/\.(png|jpg|jpeg|gif|svg|webp|bmp|ico)/i)) {
                  const absolutePath = path.join(process.cwd(), 'output', url);
                  return `${attr}="${absolutePath}"`;
                }
                return match;
              }
            );
          }

          // Function to extract images from HTML
          function extractImagesFromHtml(htmlContent) {
            const imageRegex = /<img[^>]+src="([^"]+)"[^>]*>/g;
            const images = [];
            let match;
            
            while (match = imageRegex.exec(htmlContent)) {
              const src = match[1];
              // Only include relative paths, not external URLs or data URIs
              if (!src.startsWith('http') && !src.startsWith('//') && !src.startsWith('data:')) {
                images.push(src);
              }
            }
            
            return images;
          }

          function convertToHtml(mdFile, outputHtmlPath) {
            try {
              console.log(`Converting ${mdFile} to HTML...`);
              const content = fs.readFileSync(mdFile, 'utf-8');
              const html = marked.parse(content);
              
              // Get relative path to root for style.css link
              const depth = outputHtmlPath.split('/').length - 2;
              const rootPath = depth > 0 ? '../'.repeat(depth) : './';
              
              const styledHtml = `
                <!DOCTYPE html>
                <html>
                <head>
                  <meta charset="UTF-8">
                  <meta name="viewport" content="width=device-width, initial-scale=1.0">
                  <title>${path.basename(mdFile, '.md')}</title>
                  ${rootStyleExists ? `<link rel="stylesheet" href="${rootPath}style.css">` : ''}
                  <style>
                    body {
                      font-family: "Hiragino Kaku Gothic ProN", "ヒラギノ角ゴ ProN W3", "Meiryo", "メイリオ", "MS PGothic", "MS Pゴシック", "Noto Sans CJK JP", sans-serif;
                      line-height: 1.6;
                      padding: 20px;
                      max-width: 800px;
                      margin: 0 auto;
                    }
                    pre {
                      background-color: #f6f8fa;
                      border-radius: 3px;
                      padding: 16px;
                      overflow: auto;
                    }
                    code {
                      font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
                      background-color: rgba(27, 31, 35, 0.05);
                      border-radius: 3px;
                      padding: 0.2em 0.4em;
                    }
                    pre code {
                      background-color: transparent;
                      padding: 0;
                    }
                    blockquote {
                      border-left: 4px solid #ddd;
                      padding-left: 16px;
                      color: #555;
                      margin-left: 0;
                    }
                    img {
                      max-width: 100%;
                    }
                    table {
                      border-collapse: collapse;
                      width: 100%;
                    }
                    table, th, td {
                      border: 1px solid #ddd;
                    }
                    th, td {
                      padding: 8px 12px;
                    }
                    th {
                      background-color: #f6f8fa;
                    }
                    @media print {
                      @page {
                        size: A4;
                        margin: 2cm;
                      }
                      body {
                        max-width: none;
                        padding: 0;
                      }
                    }
                  </style>
                </head>
                <body>
                  ${html}
                </body>
                </html>
              `;
              
              // Extract images from the generated HTML
              const images = extractImagesFromHtml(html);
              
              // Copy each image to the output directory maintaining relative paths
              const mdDir = path.dirname(mdFile);
              const outputDir = path.dirname(outputHtmlPath);
              
              images.forEach(imgSrc => {
                const imgFullPath = path.join(mdDir, imgSrc);
                const imgOutputPath = path.join(outputDir, imgSrc);
                
                // Try to copy the image if it exists
                if (fs.existsSync(imgFullPath)) {
                  copyFile(imgFullPath, imgOutputPath);
                } else {
                  console.warn(`Warning: Image not found: ${imgFullPath}`);
                }
              });
              
              fs.writeFileSync(outputHtmlPath, styledHtml);
              return true;
            } catch (error) {
              console.error(`Error processing ${mdFile}:`, error);
              return false;
            }
          }

          async function generatePDF(htmlPath, pdfPath) {
            try {
              console.log(`Generating PDF for ${htmlPath}...`);
              
              // Launch browser with specific args for GitHub Actions environment
              const browser = await puppeteer.launch({
                headless: 'new',
                args: [
                  '--no-sandbox',
                  '--disable-setuid-sandbox',
                  '--disable-dev-shm-usage',
                  '--disable-gpu',
                  '--font-render-hinting=none' // Helps with font rendering
                ]
              });
              
              const page = await browser.newPage();
              
              // Read the HTML file
              const htmlContent = fs.readFileSync(htmlPath, 'utf-8');
              const title = path.basename(htmlPath, '.html');
              const basePath = path.dirname(htmlPath);
              
              // Fix image paths to use absolute paths
              const fixedHtmlContent = fixImagePathsForPdf(htmlContent, basePath);
              
              // Create PDF optimized HTML with inline styles and headers/footers
              const pdfHtml = `
                <!DOCTYPE html>
                <html>
                <head>
                  <meta charset="UTF-8">
                  <title>${title}</title>
                  <style>
                    @page {
                      size: A4;
                      margin: 2cm;
                    }
                    /* Include the root style.css content directly */
                    ${rootStyleContent}
                    /* Default styling */
                    body {
                      font-family: "IPAGothic", "IPAPGothic", "VL Gothic", "Noto Sans CJK JP", "TakaoGothic", "Yu Gothic", "Meiryo UI", sans-serif;
                      line-height: 1.6;
                      padding: 20px;
                    }
                    /* Header and footer styles */
                    .header, .footer {
                      position: fixed;
                      width: 100%;
                      padding: 10px 20px;
                      background-color: #f5f5f5;
                      border-bottom: 1px solid #ddd;
                      font-family: "IPAGothic", "IPAPGothic", "VL Gothic", "Noto Sans CJK JP", sans-serif;
                    }
                    .header {
                      top: 0;
                    }
                    .footer {
                      bottom: 0;
                      text-align: right;
                    }
                    .content {
                      margin-top: 70px;
                      margin-bottom: 70px;
                    }
                    img {
                      max-width: 100%;
                      height: auto;
                    }
                    /* Extract other styles from the HTML */
                    ${htmlContent.match(/<style>([\s\S]*?)<\/style>/)?.[1] || ''}
                  </style>
                </head>
                <body>
                  <div class="header">
                    ${title} - ${new Date().toISOString().split('T')[0]}
                  </div>
                  <div class="content">
                    ${fixedHtmlContent.match(/<body>([\s\S]*?)<\/body>/)?.[1] || ''}
                  </div>
                  <div class="footer">
                    Page <span class="pageNumber"></span> of <span class="totalPages"></span>
                  </div>
                </body>
                </html>
              `;
              
              await page.setContent(pdfHtml, { 
                waitUntil: 'networkidle0',
                timeout: 60000 // Increase timeout to 60s
              });
              
              // Set default font when applicable
              await page.evaluate(() => {
                document.body.style.fontFamily = '"IPAGothic", "Noto Sans CJK JP", sans-serif';
              });
              
              // Generate PDF with A4 size
              await page.pdf({
                path: pdfPath,
                format: 'A4',
                printBackground: true,
                displayHeaderFooter: true,
                headerTemplate: '<div style="width: 100%; font-size: 10px; padding: 5px 20px; text-align: left; border-bottom: 1px solid #ddd; font-family: \'IPAGothic\', sans-serif;">{{title}}</div>',
                footerTemplate: '<div style="width: 100%; font-size: 10px; padding: 5px 20px; text-align: right; border-top: 1px solid #ddd; font-family: \'IPAGothic\', sans-serif;">Page <span class="pageNumber"></span> of <span class="totalPages"></span></div>',
                margin: {
                  top: '100px',
                  bottom: '100px',
                  left: '50px',
                  right: '50px'
                }
              });
              
              await browser.close();
              return true;
            } catch (error) {
              console.error(`Error generating PDF for ${htmlPath}:`, error);
              
              // Fallback method if the above fails
              try {
                console.log(`Trying fallback PDF generation for ${htmlPath}...`);
                const browser = await puppeteer.launch({
                  headless: true,
                  args: ['--no-sandbox', '--disable-setuid-sandbox', '--disable-dev-shm-usage']
                });
                
                const page = await browser.newPage();
                
                // Read the HTML file and fix paths
                const htmlContent = fs.readFileSync(htmlPath, 'utf-8');
                const fixedHtmlContent = fixImagePathsForPdf(htmlContent, path.dirname(htmlPath));
                
                // Write a temporary file with fixed paths
                const tempHtmlPath = htmlPath.replace('.html', '-temp.html');
                fs.writeFileSync(tempHtmlPath, fixedHtmlContent);
                
                await page.goto(`file://${path.resolve(tempHtmlPath)}`, {
                  waitUntil: 'networkidle0',
                  timeout: 60000
                });
                
                // Set font for Japanese text
                await page.evaluate(() => {
                  document.body.style.fontFamily = '"IPAGothic", "Noto Sans CJK JP", sans-serif';
                });
                
                // Simple PDF generation without streams
                await page.pdf({
                  path: pdfPath,
                  format: 'A4',
                  printBackground: true,
                  margin: {
                    top: '1cm',
                    bottom: '1cm',
                    left: '1cm',
                    right: '1cm'
                  }
                });
                
                // Clean up temporary file
                fs.unlinkSync(tempHtmlPath);
                
                await browser.close();
                return true;
              } catch (fallbackError) {
                console.error(`Fallback PDF generation also failed: ${fallbackError}`);
                return false;
              }
            }
          }

          async function processMarkdownFiles() {
            // Create output directories
            if (!fs.existsSync('output/html')) {
              fs.mkdirSync('output/html', { recursive: true });
            }
            if (!fs.existsSync('output/pdf')) {
              fs.mkdirSync('output/pdf', { recursive: true });
            }
            
            // Copy style.css to output directory if it exists
            if (rootStyleExists) {
              fs.copyFileSync('./style.css', './output/style.css');
            }
            
            // Copy all image assets to output directory
            console.log('Copying image assets to output directory...');
            copyAssets('.', './output');

            // Find all markdown files
            const getFiles = (dir, ext, files = []) => {
              const entries = fs.readdirSync(dir, { withFileTypes: true });
              
              for (const entry of entries) {
                const fullPath = path.join(dir, entry.name);
                
                if (entry.isDirectory() && entry.name !== 'node_modules' && entry.name !== '.git' && entry.name !== 'output') {
                  getFiles(fullPath, ext, files);
                } else if (entry.isFile() && entry.name.endsWith(ext)) {
                  files.push(fullPath);
                }
              }
              
              return files;
            };

            const mdFiles = getFiles('.', '.md');
            console.log(`Found ${mdFiles.length} markdown files`);
            
            const htmlFiles = [];
            const pdfFiles = [];

            for (const mdFile of mdFiles) {
              const baseName = path.basename(mdFile, '.md');
              const relativePath = path.dirname(mdFile).replace('./', '');
              let outputDir = '';
              
              // Create nested directory structure in output if needed
              if (relativePath && relativePath !== '.') {
                outputDir = relativePath + '/';
                if (!fs.existsSync(`output/html/${relativePath}`)) {
                  fs.mkdirSync(`output/html/${relativePath}`, { recursive: true });
                }
                if (!fs.existsSync(`output/pdf/${relativePath}`)) {
                  fs.mkdirSync(`output/pdf/${relativePath}`, { recursive: true });
                }
              }
              
              const htmlPath = `output/html/${outputDir}${baseName}.html`;
              const pdfPath = `output/pdf/${outputDir}${baseName}.pdf`;
              
              if (convertToHtml(mdFile, htmlPath)) {
                const displayPath = outputDir ? `${outputDir}${baseName}` : baseName;
                htmlFiles.push({ name: displayPath, path: htmlPath });
                
                // Generate PDF
                const pdfSuccess = await generatePDF(htmlPath, pdfPath);
                if (pdfSuccess) {
                  pdfFiles.push({ name: displayPath, path: pdfPath });
                }
              }
            }

            // Generate index.html
            const indexHtml = `
            <!DOCTYPE html>
            <html lang="ja">
            <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>Markdown Documents</title>
              <style>
                body {
                  font-family: "Hiragino Kaku Gothic ProN", "ヒラギノ角ゴ ProN W3", "Meiryo", "メイリオ", "MS PGothic", "MS Pゴシック", "Noto Sans CJK JP", sans-serif;
                  max-width: 800px;
                  margin: 0 auto;
                  padding: 20px;
                }
                h1 {
                  text-align: center;
                }
                .section {
                  margin-bottom: 30px;
                }
                .file-list {
                  list-style-type: none;
                  padding: 0;
                }
                .file-list li {
                  margin: 8px 0;
                  padding: 8px;
                  background-color: #f5f5f5;
                  border-radius: 4px;
                  display: flex;
                  justify-content: space-between;
                }
                .file-list a {
                  text-decoration: none;
                  color: #0366d6;
                }
                .file-list a:hover {
                  text-decoration: underline;
                }
                .formats {
                  display: flex;
                  gap: 10px;
                }
                .pdf-link {
                  color: #d64541;
                }
              </style>
            </head>
            <body>
              <h1>Markdown Documents</h1>
              
              <div class="section">
                <h2>Documents</h2>
                <ul class="file-list">
                  ${htmlFiles.map(file => {
                    const pdfFile = pdfFiles.find(pdf => pdf.name === file.name);
                    return `
                      <li>
                        <span>${file.name}</span>
                        <div class="formats">
                          <a href="${file.path}" target="_blank">HTML</a>
                          ${pdfFile ? `<a href="${pdfFile.path}" class="pdf-link" target="_blank">PDF</a>` : ''}
                        </div>
                      </li>
                    `;
                  }).join('\n')}
                </ul>
              </div>
            </body>
            </html>
            `;

            fs.writeFileSync('index.html', indexHtml);
            console.log('Generated index.html with links to all converted files');
          }

          // Use async IIFE to allow await
          (async () => {
            await processMarkdownFiles();
          })();
          EOL

      - name: Convert files
        run: node convert.js

      - name: Configure Git
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'github-actions@github.com'

      - name: Commit changes
        run: |
          git add output/ index.html
          git commit -m "Convert Markdown to HTML and PDF [automated]" || echo "No changes to commit"
          git push origin HEAD:${GITHUB_REF#refs/heads/}
